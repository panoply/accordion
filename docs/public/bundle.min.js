// ../index.js
var E = (s) => ({ emit: (o, e, c2) => {
  let t = s[o] || [], f = t.length, p = null;
  for (let l = 0; l < f; l++) {
    let a = t[l].apply(e, [c2]);
    p === null && a === false && (p = true);
  }
  return p;
}, on: (o, e) => {
  s[o] || (s[o] = []), s[o].push(e);
}, off: (o, e) => {
  let c2 = [], t = s[o];
  if (t && e) {
    let f = 0, p = t.length;
    for (; f < p; f++)
      t[f] !== e && c2.push(t[f]);
  }
  c2.length ? t[o] = c2 : delete t[o];
} });
function O(s, o) {
  let { config: e } = s, { classes: c2 } = e;
  return (t) => {
    let f = (a) => {
      s.collapsing = true;
      let { fade: i, transition: m } = a, { scrollHeight: g, style: b } = a.content, A = performance.now(), h = requestAnimationFrame(function v(d) {
        let n = Math.min((d - A) / m, 1);
        n < 1 ? (i && n > 0 && (b.opacity = `${1 - n}`), b.height = `${g - n * g}px`, h = requestAnimationFrame(v)) : n >= 1 && (b.height = "0", i && (b.opacity = "0"), a.button.ariaDisabled = "false", a.button.ariaExpanded = "false", a.button.classList.remove(c2.opened), a.content.classList.remove(c2.expanded), a.expanded = false, s.collapsing = false, cancelAnimationFrame(h));
      });
    }, p = (a) => {
      s.collapsing = true;
      let { fade: i, transition: m } = a, { scrollHeight: g, style: b } = a.content, A = performance.now();
      i || (b.opacity = "1");
      let h = requestAnimationFrame(function v(d) {
        let n = Math.min((d - A) / m, 1);
        n < 1 ? (i && n > 0 && (b.opacity = `${n}`), b.height = `${n * g}px`, h = requestAnimationFrame(v)) : n >= 1 && (i && (b.opacity = "1"), b.height = "auto", s.collapsing = false, cancelAnimationFrame(h));
      });
    }, l = (a) => {
      if (typeof a != "number")
        return s.active !== t.number && (s.active = t.number), t;
      if (s.folds[a])
        return s.active = t.number, s.folds[a];
      throw new TypeError(`No fold exists at index: ${a}`);
    };
    t.focus = () => {
      s.active = t.number, t.button.classList.add(c2.focused), o.emit("focus", s, t);
    }, t.blur = () => t.button.classList.remove(c2.focused), t.enable = (a) => {
      let i = l(a);
      i.disabled && (i.disabled = false, i.button.ariaDisabled = "false", i.button.classList.remove(c2.disabled));
    }, t.disable = (a) => {
      let i = l(a);
      i.disabled || (i.expanded ? e.persist && (i.disabled = true, i.button.ariaDisabled = "true") : (i.close(), i.disabled = true, i.button.ariaDisabled = "true", i.button.classList.add(c2.disabled)));
    }, t.close = (a) => {
      let i = l(a);
      if (e.multiple && !i.expanded)
        f(i);
      else
        for (let m of s.folds)
          if (m.expanded) {
            if (e.persist && m.number === i.number)
              break;
            f(m), i = m;
            break;
          }
      i.enable(), o.emit("collapse", s, i);
    }, t.open = (a) => {
      let i = l(a);
      i.expanded || i.disabled || (i.close(), p(i), i.expanded = true, i.button.ariaDisabled = "true", i.button.ariaExpanded = "true", i.button.classList.add(c2.opened), i.content.classList.add(c2.expanded), i.disable(), o.emit("expand", s, i));
    }, t.toggle = () => {
      if (!s.collapsing && !o.emit("toggle", s, t))
        return t.expanded ? t.close() : t.open();
    }, t.destroy = (a = false) => {
      t.close(), t.button.removeEventListener("click", t.toggle), t.button.removeEventListener("focus", t.focus), t.button.removeEventListener("blur", t.blur), a && (s.element.removeChild(t.content), s.element.removeChild(t.button));
    }, t.button.addEventListener("click", t.toggle), t.button.addEventListener("focus", t.focus), t.button.addEventListener("blur", t.blur), s.folds.push(t);
  };
}
var y = (s) => {
  let o = s.trim();
  if (!/true|false/.test(o))
    throw new TypeError(`Invalid value. Boolean expected, received: ${o}`);
  return o === "true";
};
var $ = (s) => {
  let o = s.trim();
  if (/[-]?[0-9]/.test(o)) {
    if (o.charCodeAt(0) === 45)
      throw new TypeError(`Negative transition is not allowed: ${o}`);
    return Number(o);
  }
  return y(o) ? 300 : 0;
};
var F = (s, o) => {
  let e = /* @__PURE__ */ Object.create(null), c2 = /* @__PURE__ */ Object.create(null);
  c2.opened = "opened", c2.disabled = "disable", c2.expanded = "expanded", c2.focused = "focused", "classes" in s && Object.assign(c2, s.classes), e.classes = c2, e.persist = true, e.multiple = false, e.fade = true, e.schema = "data-accordion", typeof s == "object" && Object.assign(e, s);
  let t = /^(?:preserve|persist|multiple|keyboard|transition|fade)$/, f = e.schema === null ? 5 : e.schema.length + 1;
  for (let { nodeName: p, nodeValue: l } of o) {
    let a = p.slice(f);
    t.test(a) && (e[a] = a === "transition" ? $(l) : y(l));
  }
  return "transition" in e || (e.transition = 300), e;
};
function w(s, o) {
  window.relapse instanceof Map || (window.relapse = /* @__PURE__ */ new Map());
  let e = /* @__PURE__ */ Object.create(null);
  if (e.folds = [], e.events = /* @__PURE__ */ Object.create(null), e.element = typeof s == "string" ? document.body.querySelector(s) : s, e.id = e.element.id ? e.element.id : `A${window.relapse.size}`, window.relapse.has(e.id))
    throw new TypeError(`An accordion using id ${e.id} alrerady exists`);
  e.config = F(o, e.element.attributes), e.element.ariaMultiSelectable = `${e.config.multiple}`, e.collapsing = false;
  let c2 = e.element.children, t = c2.length, f = E(e.events), p = O(e, f), { classes: l, schema: a, transition: i, fade: m } = e.config, g = a === null ? "data" : a, b = `${g}-fade`, A = `${g}-transition`, h = `${g}-prevent`;
  for (let d = 0; d < t; d = d + 2) {
    let n = c2[d], u = c2[d + 1], r = /* @__PURE__ */ Object.create(null);
    r.number = e.folds.length;
    let L = n.classList.contains(l.opened), x = n.classList.contains(l.disabled), I = u.classList.contains(l.expanded);
    n.ariaExpanded === "true" || L || I ? (L ? n.ariaExpanded = "true" : n.classList.add(l.opened), I || u.classList.add(l.expanded), x || n.classList.add(l.disabled), n.ariaDisabled = "true", r.expanded = true, r.disabled = true) : n.ariaDisabled === "true" || x ? (x ? n.ariaDisabled = "false" : n.classList.add(l.disabled), u.classList.remove(l.expanded), n.classList.remove(l.opened), n.ariaExpanded = "false", r.expanded = false, r.disabled = true) : (r.expanded = false, r.disabled = false, n.ariaExpanded = "false", n.ariaDisabled = "false"), r.transition = i, r.fade = m, n.id && (r.id = n.id), u.id && (r.id = u.id), "id" in r || (r.id = `${e.id}F${r.number}`, n.id = `B${r.id}`, u.id = `C${r.id}`), n.hasAttribute(A) && (r.transition = $(n.getAttribute(A))), u.hasAttribute(A) && (r.transition = $(u.getAttribute(A))), n.hasAttribute(b) && (r.fade = y(n.getAttribute(b))), u.hasAttribute(b) && (r.fade = y(u.getAttribute(b))), r.fade || (u.style.opacity = "1"), n.setAttribute("aria-controls", r.id), u.setAttribute("aria-labelledby", n.id), u.setAttribute("role", "region"), r.button = n, r.content = u, p(r);
  }
  let v = (d, n, u = false) => {
    if (typeof n == "number")
      return d.charCodeAt(0) === 100 ? e.folds[n][d](u) : e.folds[n][d]();
    if (typeof n == "string") {
      for (let r of e.folds)
        if (r.button.dataset[`${e.config.schema}-fold`] === n)
          return d.charCodeAt(0) === 100 ? r[d](u) : r[d]();
    }
    throw new TypeError(`Fold does not exist: "${n}"`);
  };
  return e.on = f.on, e.off = f.off, e.collapse = (d) => v("close", d), e.expand = (d) => v("open", d), e.destroy = (d, n = false) => {
    if (typeof d == "undefined")
      for (let u of e.folds)
        u.destroy();
    else
      v("destroy", d, n);
    e.element.removeAttribute("aria-multiselectable"), f.emit("destroy", e), window.relapse.delete(e.id);
  }, window.relapse.set(e.id, e), e;
}

// site/assets/bundle.ts
var c = w(document.querySelector("#accordion"), {
  transition: 300,
  multiple: false
});
c.on("toggle", function(fold) {
});
