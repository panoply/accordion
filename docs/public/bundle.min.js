(function () {
  'use strict';

  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../../brixtol/packages/spx/index.js
  var yr = Object.defineProperty;
  var Er = (e2, t2) => {
    for (var o in t2)
      yr(e2, o, { get: t2[o], enumerable: true });
  };
  var D = typeof window != "undefined" ? window : { screen: {}, navigator: {} };
  var be = (D.matchMedia || function() {
    return { matches: false };
  }).bind(D);
  var xr = { get passive() {
    return true;
  } };
  var eo = function() {
  };
  D.addEventListener && D.addEventListener("p", eo, xr);
  D.removeEventListener && D.removeEventListener("p", eo, false);
  var bt = "ontouchstart" in D;
  var Tr = "TouchEvent" in D;
  var It = bt || Tr && be("(any-pointer: coarse)").matches;
  var Qt = (D.navigator.maxTouchPoints || 0) > 0 || It;
  var to = D.navigator.userAgent || "";
  var br = be("(pointer: coarse)").matches && /iPad|Macintosh/.test(to) && Math.min(D.screen.width || 0, D.screen.height || 0) >= 768;
  var Ir = (be("(pointer: coarse)").matches || !be("(pointer: fine)").matches && bt) && !/Windows.*Firefox/.test(to);
  var Ar = be("(any-pointer: fine)").matches || be("(any-hover: hover)").matches || br || !bt;
  var Oe = Qt && (Ar || !Ir) ? "hybrid" : Qt ? "touchOnly" : "mouseOnly";
  var At = typeof window != "undefined";
  "content" in document.createElement("template");
  document.createRange && "createContextualFragment" in document.createRange();
  var M = It ? "pointer" : "mouse";
  var le = window.location.origin;
  var { assign: R, keys: vn, entries: xn } = Object;
  var Q = Object.defineProperty;
  var X = Object.defineProperties;
  var oo = Object.create;
  var { isArray: O } = Array;
  var ro = Array.from;
  var v = "";
  var { warn: Pt, info: no, error: Nt } = console;
  var A = () => document.body;
  var so = () => document.head;
  var m = (e2) => e2 ? R(oo(null), e2) : oo(null);
  var Y = (e2) => new Set(e2);
  var io = (e2) => new Proxy(m(), e2);
  var U = () => /* @__PURE__ */ new Map();
  var E = class extends XMLHttpRequest {
    constructor() {
      super(...arguments);
      this.key = null;
    }
  };
  E.o = U(), E.a = U(), E.r = m();
  var n = m({ index: "", eval: true, patched: false, loaded: false, qs: m(), config: m({ fragments: ["body"], timeout: 3e4, globalThis: true, schema: "spx-", manual: false, logLevel: 2, cache: true, maxCache: 100, reverse: true, preload: null, annotate: false, eval: m({ script: null, style: null, link: null, meta: false }), hover: m({ trigger: "href", threshold: 250 }), intersect: m({ rootMargin: "0px 0px 0px 0px", threshold: 0 }), proximity: m({ distance: 75, threshold: 250, throttle: 500 }), progress: m({ bgColor: "#111", barHeight: "3px", minimum: 0.08, easing: "linear", speed: 200, threshold: 500, trickle: true, trickleSpeed: 200 }) }), fragments: U(), components: m({ registry: U(), instances: U(), connected: Y(), elements: U(), reference: io({ get: (e2, t2) => n.components.instances.get(e2[t2]) }) }), events: m(), observe: m(), memory: m(), pages: m(), snaps: m(), resources: Y() });
  var Se = "\x1B[96mSPX\x1B[0m ";
  function p(e2, t2, o) {
    let { logLevel: r } = n.config;
    if (O(t2) && (t2 = t2.join(" ")), e2 === 1 && r === 1 || e2 === 2 && (r === 1 || r === 2))
      no(`${Se}%c${t2}`, `color: ${o || "#999"};`);
    else if (e2 === 3 && r < 4)
      o ? Pt(Se + t2, o) : Pt(Se + t2);
    else if (e2 === 5 || e2 === 4) {
      o ? Nt(Se + t2, o) : Nt(Se + t2);
      try {
        throw e2 === 4 ? new TypeError(t2) : new Error(t2);
      } catch (s) {
      }
    }
  }
  var ao = /\b(?:append|prepend)/;
  var co = /\s+/g;
  var Me = /^\b(?:true|false)$/i;
  var Je = /^\d*\.?\d+$/;
  var qe = /^(?:[.-]?\d*\.?\d+|NaN)$/;
  var fo = /\b(?:intersect|hover|proximity)\b/;
  var lo = /\b(?:SCRIPT|STYLE|LINK)\b/;
  var po = /\[(['"]?.*['"]?,?)\]/;
  var Ct = /[xy]\s*|\d*\.?\d+/gi;
  function uo(e2) {
    let t2 = e2.replace(/\s+,/g, ",").replace(/,\s+/g, ",").replace(/['"]/g, v);
    return t2.charCodeAt(0) === 91 && (/^\[\s*\[/.test(t2) || /,/.test(t2) && /\]$/.test(t2)) && (t2 = t2.replace(/^\[/, v).replace(/\]$/, v)), t2.split(/,|\|/);
  }
  function Ie(e2, t2) {
    try {
      let o = (t2 || e2).replace(/\\'|'/g, (r) => r[0] === "\\" ? r : '"').replace(/([{,])\s*(.+?)\s*:/g, '$1 "$2":');
      return JSON.parse(o);
    } catch (o) {
      return p(5, "Invalid JSON expression in attribute value: " + JSON.stringify(e2 || t2, null, 2), o), t2;
    }
  }
  function Ae(e2) {
    return e2[e2.length - 1];
  }
  function Pr(e2) {
    return e2.replace(/\s+/g, " ").trim();
  }
  function go(e2) {
    return e2.replace(/\./g, "\\.").replace(/@/g, "\\@").replace(/:/g, "\\:");
  }
  function Ze(e2) {
    return Pr(e2.replace(/[\s .]+/g, ".")).replace(/\s+/g, " ").trim().split(/[ ,]/);
  }
  function ho(e2) {
    if (qe.test(e2))
      return e2 === "NaN" ? NaN : +e2;
    if (Me.test(e2))
      return e2 === "true";
    let t2 = e2.charCodeAt(0);
    return t2 === 123 || t2 === 91 ? Ie(e2) : e2;
  }
  function yo() {
    return new Promise((e2) => setTimeout(() => e2(), 1));
  }
  function H(e2) {
    setTimeout(() => e2(), 1);
  }
  function Eo() {
    return Promise.resolve();
  }
  function vo(e2) {
    let t2 = document.createElement("textarea");
    return t2.innerHTML = e2, t2.value;
  }
  function Qe() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function Pe(e2) {
    return (t2) => t2 ? typeof t2 == "string" ? t2 in e2 : t2.every((o) => o in e2) : false;
  }
  function T(e2, t2) {
    return e2 ? t2 in e2 : false;
  }
  function et(e2, t2, o) {
    if (arguments.length > 1)
      Q(e2, t2, { get() {
        return o;
      } });
    else
      return (r, s, i2) => {
        if (T(e2, r))
          return;
        function a2() {
          return s;
        }
        return Q(e2, r, i2 ? R(i2, { get: a2 }) : { get: a2 });
      };
  }
  function Rt(e2) {
    return T(e2, "target") ? e2.target.length === 1 && e2.target[0] === "body" ? e2.target : e2.target.filter((t2, o, r) => t2 !== "body" && t2 !== v && t2.indexOf(",") === -1 ? r.indexOf(t2) === o : false) : n.config.fragments.length === 1 && n.config.fragments[0] === "body" ? ["body"] : [];
  }
  function we(e2) {
    return e2.length === 1 && e2[0] === "body" ? "body" : e2.length === 0 ? null : e2.join(",");
  }
  function Ne(e2) {
    let t2 = typeof e2;
    if (t2 === "object") {
      for (let o in e2)
        return false;
      return true;
    } else {
      if (t2 === "string")
        return e2[0] === void 0;
      if (O(e2))
        return e2.length > 0;
    }
    return false;
  }
  function xo(...e2) {
    return e2.join(v);
  }
  var W = function e(t2 = 5) {
    let o = Math.random().toString(36).slice(-t2);
    return e.g.has(o) ? e(t2) : (e.g.add(o), o);
  };
  W.g = Y();
  function To(e2 = 2) {
    return (t2, o) => {
      let r = t2.length;
      return (r < 1 || t2[r - 1].length === e2 ? t2.push([o]) : t2[r - 1].push(o)) && t2;
    };
  }
  function bo(e2) {
    return e2 < 1024 ? e2 + " B" : e2 < 1048576 ? (e2 / 1024).toFixed(1) + " KB" : e2 < 1073741824 ? (e2 / 1048576).toFixed(1) + " MB" : (e2 / 1073741824).toFixed(1) + " GB";
  }
  function tt(e2) {
    return e2[0].toLowerCase() + e2.slice(1);
  }
  function He(e2) {
    return e2[0].toUpperCase() + e2.slice(1);
  }
  function pe(e2) {
    return /[_-]/.test(tt(e2)) ? e2.replace(/([_-]+).{1}/g, (t2, o) => t2[o.length].toUpperCase()) : e2;
  }
  function ee(e2, t2) {
    let o = typeof e2 == "string" ? A().querySelectorAll(e2) : e2, r = o.length;
    if (r !== 0)
      for (let s = 0; s < r && t2(o[s], s) !== false; s++)
        ;
  }
  function B(e2, t2) {
    if (arguments.length === 1)
      return (r) => B(e2, r);
    let o = t2.length;
    if (o !== 0)
      for (let r = 0; r < o; r++)
        e2(t2[r], r, t2);
  }
  function $t(e2) {
    for (let t2 in e2)
      delete e2[t2];
  }
  function Ao() {
    if (n.patched)
      return;
    n.patched = true;
    let e2 = Element.prototype.setAttribute, t2 = document.createElement("i");
    Element.prototype.setAttribute = function(r, s) {
      if (r.indexOf("@") < 0)
        return e2.call(this, r, s);
      t2.innerHTML = `<i ${r}="${s}"></i>`;
      let i2 = t2.firstElementChild.getAttributeNode(r);
      t2.firstElementChild.removeAttributeNode(i2), this.setAttributeNode(i2);
    };
  }
  function Nr() {
    let e2 = [], t2 = document.createElement("div"), o = null, r, s = null, i2 = ({ bgColor: h, barHeight: b, speed: fe, easing: hr }) => {
      t2.style.cssText = xo("pointer-events:none;", `background-color:${h};`, `height:${b};`, "position:fixed;", "display:block;", "z-index:2147483647;", "top:0;", "left:0;", "width:100%;", "will-change:opacity,transform;", `transition:transform ${fe}ms ${hr};`);
    }, a2 = (h) => (-1 + h) * 100, c2 = (h, b, fe) => h < b ? b : h > fe ? fe : h, f2 = () => s || (t2.style.setProperty("transform", `translateX(${a2(o || 0)}%)`), s = A().appendChild(t2), t2), l2 = () => {
      let h = A();
      if (h.contains(s)) {
        let b = s.animate({ opacity: ["1", "0"] }, { easing: "ease-out", duration: 100 });
        b.onfinish = () => {
          h.removeChild(s), s = null;
        };
      } else
        s = null;
    }, u2 = () => {
      let h = e2.shift();
      h && h(u2);
    }, d = (h) => {
      e2.push(h), e2.length === 1 && u2();
    }, y = (h) => {
      h = c2(h, n.config.progress.minimum, 1), o = h === 1 ? null : h;
      let b = f2();
      d((fe) => {
        b.style.setProperty("transform", `translateX(${a2(h)}%)`), h === 1 ? setTimeout(() => {
          l2(), fe();
        }, n.config.progress.speed * 2) : setTimeout(fe, n.config.progress.speed);
      });
    }, x = (h) => {
      let b = o;
      if (!b)
        return ce();
      if (b < 1)
        return typeof h != "number" && (b >= 0 && b < 0.2 ? h = 0.1 : b >= 0.2 && b < 0.5 ? h = 0.04 : b >= 0.5 && b < 0.8 ? h = 0.02 : b >= 0.8 && b < 0.99 ? h = 5e-3 : h = 0), b = c2(b + h, 0, 0.994), y(b);
    }, S2 = () => {
      setTimeout(() => {
        o && (x(), S2());
      }, n.config.progress.trickleSpeed);
    };
    function ce(h) {
      n.config.progress && (r = setTimeout(() => {
        o || y(0), n.config.progress.trickle && S2();
      }, h || 0));
    }
    function gr(h) {
      clearTimeout(r), !(!h && !o) && (x(0.3 + 0.5 * Math.random()), y(1));
    }
    return { start: ce, done: gr, style: i2 };
  }
  var me = Nr();
  function ot(e2, t2) {
    let { name: o } = e2, r = t2;
    t2 ? t2 = tt(t2) : t2 = tt(e2.name), T(e2, "connect") || (e2.connect = { id: t2, state: {}, nodes: [] });
    let s = Pe(e2.connect);
    return s("state") || (e2.connect.state = {}), s("nodes") || (e2.connect.nodes = []), s("id") || (e2.connect.id = t2), t2 !== e2.connect.id && (t2 = pe(e2.connect.id)), o !== r && /^[A-Z]|[_-]/.test(e2.connect.id) && p(3, [`Component identifer name "${e2.connect.id}" must use camelCase format.`, `The identifer has been converted to "${t2}"`]), t2;
  }
  function te(e2) {
    let { registry: t2 } = n.components;
    for (let o in e2) {
      let r = e2[o], s = ot(r, o);
      t2.has(s) || (t2.set(s, r), p(1, `${o} component registered under: ${s}`));
    }
  }
  function Cr(e2) {
    for (let t2 of ["hover", "intersect", "proximity", "progress"])
      T(e2, t2) && (e2[t2] === false ? n.config[t2] = false : typeof e2[t2] == "object" && R(n.config[t2], e2[t2]), delete e2[t2]);
    return e2;
  }
  function ke(e2, t2) {
    let o = `:not([${e2}${t2}=false]):not([${e2}link])`;
    switch (t2.charCodeAt(0)) {
      case 104:
        return `${o}:not([${e2}proximity]):not([${e2}intersect])`;
      case 105:
        return `${o}:not([${e2}hover]):not([${e2}proximity])`;
      case 112:
        return `${o}:not([${e2}intersect]):not([${e2}hover])`;
    }
  }
  function Rr(e2, t2, o) {
    if ("eval" in e2)
      if (e2.eval) {
        if (typeof e2.eval == "object") {
          let r = R(n.config.eval, e2.eval);
          n.eval = !(!r.link && !r.meta && !r.script && !r.style);
        }
      } else
        n.eval = false;
    return (r) => {
      if (n.eval === false || n.config.eval[r] === false)
        return `${r}[${t2}eval]:${o}`;
      if (n.config.eval[r] === true)
        return `${r}:${o}`;
      let s = r === "link" ? `${r}[rel=stylesheet]:${o}` : r === "script" ? `${r}:${o}:not([${t2}eval=hydrate])` : `${r}:${o}`;
      if (n.config.eval[r] === null)
        return s;
      if (O(n.config.eval[r]))
        return n.config.eval[r].length > 0 ? n.config.eval[r].map((i2) => `${i2}:${o}`).join(",") : (p(3, `Missing eval ${r} value, SPX will use defaults`), s);
      p(4, `Invalid eval ${r} value, expected boolean or array`);
    };
  }
  function $r(e2) {
    let t2 = [];
    if ("fragments" in e2 && O(e2.fragments) && e2.fragments.length > 0)
      for (let o of e2.fragments) {
        let r = o.charCodeAt(0);
        if (r === 46 || r === 91) {
          p(3, [`Invalid fragment selector "${o}" provided. Fragments must be id annotated values.`, "Use spx-target attributes for additional fragment selections."]);
          continue;
        } else
          r === 35 ? t2.push(o.slice(1).trim()) : t2.push(o.trim());
      }
    return t2;
  }
  function Po(e2 = m()) {
    Ao(), X(n, { ready: { get() {
      return document.readyState === "complete";
    } }, types: { get() {
      return m({ INITIAL: 0, PREFETCH: 1, FETCH: 2, PRELOAD: 3, REVERSE: 4, POPSTATE: 5, VISIT: 6, HYDRATE: 7, CAPTURE: 8, RELOAD: 9, HOVER: 10, INTERSECT: 11, PROXIMITY: 12 });
    } } }), "components" in e2 ? (te(e2.components), delete e2.components, n.config.components = true) : n.config.components = false, R(n.config, Cr(e2));
    let t2 = n.config.schema, o = t2 === "spx" ? "spx" : t2.endsWith("-") ? t2 : t2 === null ? v : `${t2}-`, r = `:not([${o}disable]):not([href^=\\#])`, s = `not([${o}eval=false])`, i2 = Rr(e2, o, s);
    n.config.fragments = $r(e2), n.config.schema = o, n.config.index = null, n.memory.bytes = 0, n.memory.visits = 0, n.memory.limit = n.config.maxCache, R(n.qs, { x: new RegExp(`^href|${o}(hydrate|append|prepend|target|progress|threshold|scroll|position|proximity|hover|cache|history)$`, "i"), O: new RegExp(`${o}(?:node|bind|component)|@[a-z]|[a-z]:[a-z]`, "i"), T: new RegExp(`^${o}[a-zA-Z0-9-]+:`, "i"), m: `${o}target`, h: `[${o}target]:not([${o}target=false])`, c: `${o}morph`, b: `${o}eval`, I: `[${o}intersect]${ke(o, "intersect")}`, S: `[${o}track]:not([${o}track=false])`, u: `${o}component`, y: `${o}node`, E: `${o}bind`, e: "data-spx", A: n.config.annotate ? `a[${o}link]${r}` : `a${r}`, P: i2("script"), N: i2("style"), C: i2("link"), R: i2("meta"), M: `script[${o}eval=hydrate]:${s}`, q: `link[rel=stylesheet][href*=\\.css]:${s},script[src*=\\.js]:${s}`, d: `${o}data:`, v: `a[${o}proximity]${r}${ke(o, "proximity")}`, L: `a${r}${ke(o, "intersect")}`, l: n.config.hover !== false && n.config.hover.trigger === "href" ? `a${r}${ke(o, "hover")}` : `a[${o}hover]${r}${ke(o, "hover")}` }), me.style(n.config.progress);
  }
  function ue(e2) {
    return new DOMParser().parseFromString(e2, "text/html");
  }
  function de(e2) {
    return (e2 || document).documentElement.outerHTML;
  }
  function Lt(e2) {
    let t2 = e2.indexOf("<title");
    if (t2 === -1)
      return v;
    let o = e2.indexOf(">", t2) + 1, r = e2.indexOf("</title", o);
    return vo(e2.slice(o, r).trim());
  }
  function L(e2, ...t2) {
    let o = e2 === "before:cache";
    o && (t2[1] = ue(t2[1]));
    let r = true;
    return B((s) => {
      let i2 = s.apply(null, t2);
      o ? i2 instanceof Document ? r = i2.documentElement.outerHTML : typeof r != "string" && (r = i2 !== false) : r = i2 !== false;
    }, n.events[e2] || []), r;
  }
  function No(e2, t2, o) {
    return e2 in n.events || (n.events[e2] = []), n.events[e2].push(o ? t2.bind(o) : t2) - 1;
  }
  function Co(e2, t2) {
    if (e2 in n.events) {
      let o = n.events[e2];
      if (o && typeof t2 == "number")
        o.splice(t2, 1), p(2, `Removed ${e2} event listener (id: ${t2})`), o.length === 0 && delete n.events[e2];
      else {
        let r = [];
        if (o && t2)
          for (let s = 0, i2 = o.length; s < i2; s++)
            o[s] !== t2 ? r.push(o[s]) : p(2, `Removed ${e2} event listener (id: ${s})`);
        r.length ? n.events[e2] = r : delete n.events[e2];
      }
    } else
      p(3, `There are no ${e2} event listeners`);
    return this;
  }
  function De(e2, { method: t2 = "GET", body: o = null, headers: r = null, type: s = "text" } = {}) {
    return new Promise(function(i2, a2) {
      let c2 = new E();
      if (c2.key = e2, c2.responseType = s, c2.open(t2, e2), c2.setRequestHeader("spx-request", "true"), r !== null)
        for (let f2 in r)
          c2.setRequestHeader(f2, r[f2]);
      c2.onloadstart = function() {
        E.o.set(this.key, c2);
      }, c2.onload = function() {
        i2(this.response);
      }, c2.onerror = function() {
        a2(this.statusText);
      }, c2.onabort = function() {
        delete E.r[this.key], E.a.delete(this.key), E.o.delete(this.key);
      }, c2.onloadend = function(f2) {
        E.o.delete(this.key), n.memory.bytes = n.memory.bytes + f2.loaded, n.memory.visits = n.memory.visits + 1;
      }, c2.send(o);
    });
  }
  function rt(e2) {
    return e2 in E.r ? (clearTimeout(E.r[e2]), delete E.r[e2]) : true;
  }
  function nt(e2, t2, o) {
    e2 in E.r || q(e2) || (E.r[e2] = setTimeout(t2, o));
  }
  function Ot(e2) {
    for (let [t2, o] of E.o)
      e2 !== t2 && (o.abort(), p(3, `Pending request aborted: ${t2}`));
  }
  function Ro(e2) {
    if (n.config.preload !== null) {
      if (O(n.config.preload)) {
        let t2 = n.config.preload.filter((o) => {
          let r = I(o, 3);
          return r.key !== o ? $(C(r)) : false;
        });
        return Promise.allSettled(t2);
      } else if (typeof n.config.preload == "object" && T(n.config.preload, e2.key)) {
        let t2 = n.config.preload[e2.key].map((o) => $(C(I(o, 3))));
        return Promise.allSettled(t2);
      }
    }
  }
  function st(e2) {
    return __async(this, null, function* () {
      if (e2.rev === e2.key)
        return;
      let t2 = C(I(e2.rev, 4));
      yield yo(), $(t2).then((o) => {
        o ? p(2, `Reverse fetch completed: ${o.rev}`) : p(3, `Reverse fetch failed: ${e2.rev}`);
      });
    });
  }
  function We(e2) {
    return __async(this, null, function* () {
      if (!E.a.has(e2.key))
        return e2;
      let t2 = yield E.a.get(e2.key);
      return E.a.delete(e2.key), delete E.r[e2.key], Ce(e2, t2);
    });
  }
  function $(e2) {
    return __async(this, null, function* () {
      return E.o.has(e2.key) && e2.type !== 7 ? (e2.type === 4 && E.o.has(e2.rev) ? (E.o.get(e2.rev).abort(), p(3, `Request aborted: ${e2.rev}`)) : p(3, `Request in transit: ${e2.key}`), false) : L("fetch", e2) ? (E.a.set(e2.key, De(e2.key)), We(e2)) : (p(3, `Request cancelled via dispatched event: ${e2.key}`), false);
    });
  }
  function Ve(e2, t2) {
    if (t2(e2) === false)
      return;
    let o, r;
    for (e2.firstElementChild && (r = 0, o = e2.children[r]); o; )
      (o.nodeName === "svg" || o.nodeName === "CODE") && o.childElementCount > 0 && (r = 0, o = o.nextElementSibling), o && Ve(o, t2), o = e2.children[++r];
  }
  function $o(e2, t2) {
    return `on${e2}` in t2 ? true : (p(5, [`Invalid event name "${e2}" provided. No such event exists in the DOM API.`, "Only known event listeners can be attached."], t2), false);
  }
  function Lo(e2, t2, o) {
    let r = e2[t2.method];
    return function(i2) {
      t2.params && (T(i2, "attrs") || et(i2, "attrs", m()), R(i2.attrs, t2.params)), r.call(e2, i2);
    };
  }
  function Fe(e2, t2) {
    t2.attached && (t2.listener.abort(), t2.listener = new AbortController(), t2.options.signal = t2.listener.signal, t2.attached = false, n.components.elements.delete(t2.el), p(1, [`Detached ${t2.key} ${t2.eventName} event from the ${t2.method} method on`, `${e2.static.id} component (${e2.scope.key})`]));
  }
  function it(e2, t2, o) {
    if (!o.attached) {
      if (!(o.method in e2)) {
        p(3, `Undefined callback method: ${e2.static.id}.${o.method}()`);
        return;
      }
      Oo(t2.attributes, o), o.isWindow ? $o(o.eventName, window) && addEventListener(o.eventName, Lo(e2, o)) : $o(o.eventName, t2) && (t2.addEventListener(o.eventName, Lo(e2, o), o.options), n.components.elements.set(o.el, t2)), p(1, [`Attached ${o.key} ${o.eventName} event to the ${o.method} method on`, `${e2.static.id} component (${e2.scope.key})`]), o.attached = true;
    }
  }
  function So(e2) {
    H(() => at(z(n.page.key).body, e2));
  }
  function St(e2, t2, o, r) {
    let s, i2, a2;
    for (e2.firstElementChild && (s = 0, i2 = e2.children[s], a2 = t2.children[s]); i2; )
      i2.nodeName === "svg" && i2.childElementCount > 0 && (s = 0, i2 = i2.nextElementSibling, a2 = a2.nextElementSibling), i2 && (r.has(a2) ? (at(i2, o, true), r.delete(a2)) : a2.hasAttribute(n.qs.e) && i2.setAttribute(n.qs.e, a2.getAttribute(n.qs.e)), St(i2, a2, o, r)), i2 = e2.children[++s], a2 = t2.children[s];
  }
  function at(e2, t2, o = false) {
    let { elements: r } = n.components;
    Ve(e2, (s) => {
      if (oe(s.attributes) && !s.hasAttribute(n.qs.e)) {
        let i2 = t2.shift(), a2 = s.getAttribute(n.qs.e), f2 = r.get(i2).getAttribute(n.qs.e);
        if (a2 !== f2 && s.setAttribute(n.qs.e, f2), t2.length === 0)
          return o === false && (ct(s.ownerDocument.documentElement.outerHTML), p(1, "Snapshot updated")), false;
      }
    });
  }
  function Mt(e2, t2) {
    let { page: o, dom: r } = Mo(n.page.key), s = e2.charCodeAt(0) === 114 ? "removed" : "appended";
    r.head.contains(t2) ? (r.head[e2](t2), n.snaps[o.snap] = r.documentElement.outerHTML, p(1, `Snapshot record was updated. Node ${s} from <head>`, t2)) : p(3, "Node does not exists in snapshot record, no mutation applied", t2);
  }
  function Lr(e2, { nodes: t2 }) {
    let o = m();
    for (let r in t2)
      t2[r].schema in o || (o[t2[r].schema] = []), o[t2[r].schema].push(t2[r].dom);
    console.log(o);
    for (let r in o) {
      let s = o[r];
      s.length > 1 ? X(e2, { [r]: { get() {
        return n.components.elements.get(s[0]);
      } }, [`${r}s`]: { get() {
        return s.map((i2) => n.components.elements.get(i2));
      } } }) : Q(e2, r, { get() {
        return n.components.elements.get(s[0]);
      } });
    }
  }
  function ft({ p: e2, f: t2, n: o, c: r }) {
    n.page.type === 0 && o.length > 0 && So(o);
    let s = n.page.type === 4, { elements: i2, connected: a2, instances: c2, registry: f2, reference: l2 } = n.components;
    for (let u2 in e2)
      for (let d of e2[u2]) {
        if (d.instanceOf === null)
          if (u2 in t2)
            d.instanceOf = t2[u2];
          else
            continue;
        let y, x;
        if (d.mounted === false && (r !== null || s)) {
          let S2 = qo();
          d.alias !== null && d.alias in S2 ? (x = S2[d.alias][0], y = x.static) : d.instanceOf in S2 && S2[d.instanceOf].length === 1 && (x = S2[d.instanceOf][0], y = x.static), d.key = x.scope.key, d.ref = x.scope.ref;
        } else
          y = f2.get(d.instanceOf), x = new y(d, y.connect);
        if (Lr(x, d), r === null && "nodes" in y && y.nodes.length > 0)
          for (let S2 of y.nodes)
            Q(x, `has${He(S2)}Node`, { get() {
              return `${S2}Node` in this;
            } });
        for (let S2 in d.events) {
          let ce;
          r !== null && d.mounted === false ? (ce = x.scope.events[S2] = d.events[S2], l2[S2] = x.scope.key) : ce = d.events[S2], it(x, i2.get(ce.dom), ce);
        }
        (r === null || (r !== null || s) && d.mounted === true) && (a2.add(d.key), c2.set(d.key, x), p(1, `Mounted (init) component ${x.static.id} (${d.key})`, "#6dd093"), "oninit" in x && x.oninit(n.page), "onload" in x && x.onload(n.page));
      }
  }
  function lt() {
    let e2 = [];
    for (let t2 of n.page.fragments) {
      let o = document.getElementById(t2);
      o ? (n.fragments.set(t2, o), e2.push(t2)) : n.fragments.delete(t2);
    }
    K("fragments", e2);
  }
  function wo(e2) {
    e2.type !== 6 && H(() => {
      let t2 = z(e2.snap), o = e2.selector !== "body" && e2.selector !== null ? `${e2.target.join()},${n.qs.h}` : n.qs.h, r = t2.body.querySelectorAll(o), s = e2.type === 0 ? A().querySelectorAll(o) : null;
      console.log(r, s), ee(r, (i2, a2) => {
        if (!i2.hasAttribute("id"))
          i2.setAttribute("id", `t.${W()}`), s !== null && s[a2].setAttribute("id", `t.${W()}`);
        else if (i2.id.startsWith("t."))
          return;
        e2.fragments.push(i2.id);
      }), ct(t2.documentElement.outerHTML, e2.snap);
    });
  }
  function qt(e2) {
    for (let [t2, o] of n.fragments)
      if (t2 === e2.id || o.contains(e2))
        return true;
    return false;
  }
  function Or(e2) {
    return e2.trim().replace(/\s+/, " ").split(/[|, ]/).map(pe);
  }
  function Oo(e2, t2) {
    for (let o = 0, r = e2.length; o < r; o++) {
      let { name: s, value: i2 } = e2[o];
      if (n.qs.T.test(s) && !s.startsWith(n.qs.d) && i2) {
        let a2 = s.slice(n.config.schema.length).split(":").pop();
        t2.params === null && (t2.params = m()), a2 in t2.params || (t2.params[a2] = ho(i2));
      }
    }
  }
  function oe(e2) {
    if (typeof e2 == "string")
      return e2.indexOf("@") > -1 || e2 === n.qs.u || e2 === n.qs.y || e2 === n.qs.E;
    for (let t2 = e2.length - 1; t2 >= 0; t2--)
      if (oe(e2[t2].name))
        return true;
    return false;
  }
  function Re(e2, t2) {
    oe(e2.attributes) && (e2.hasAttribute(n.qs.u) ? wr(e2, e2.getAttribute(n.qs.u), t2) : Ho(e2, t2, null, null));
  }
  function mt(e2 = null) {
    return m({ f: m(), p: m(), t: null, n: [], c: e2, w: e2 ? m() : null });
  }
  function ut(e2, { p: t2, f: o }) {
    return e2 in t2 ? e2 in o ? Ae(t2[o[e2]]) : Ae(t2[e2]) : e2 in o ? Ae(t2[o[e2]]) : (t2[e2] = [wt(e2)], t2[e2][0]);
  }
  function re(e2, t2, o) {
    n.components.reference[o] = t2;
    let r = e2.getAttribute(n.qs.e), s = r ? `${r},${o}` : o;
    return e2.setAttribute(n.qs.e, s), o;
  }
  function wt(e2, t2, o) {
    let { registry: r } = n.components, s = W(), i2 = m({ key: s, mounted: false, ref: `c.${s}`, state: m(), nodes: m(), events: m(), binds: m() });
    return t2 && (re(t2, s, i2.ref), i2.dom = o.t, i2.mounted = true, i2.inFragment = qt(t2), t2.hasAttribute("id") && (i2.alias = pe(t2.id.trim()))), r.has(e2) ? (i2.instanceOf = e2, i2.alias ? r.has(i2.alias) ? p(5, [`Component alias "${i2.alias}" matches a component identifer in the registry.`, "An alias reference must be unique and cannot match component names."]) : o.f[i2.alias] = e2 : i2.alias = null) : (i2.alias = e2 || null, i2.instanceOf = null, i2.mounted && (o.f[i2.alias] = null)), i2;
  }
  function Sr(e2, t2, o, r) {
    let s = m(), i2 = o.indexOf("{"), a2 = t2.slice(n.config.schema.length), c2 = new AbortController();
    s.key = `e.${W()}`, s.dom = `${r.t}`, s.isWindow = a2.startsWith("window:"), s.eventName = s.isWindow ? a2.slice(7) : a2, s.attached = false, s.params = null, s.options = { signal: c2.signal };
    let f2 = o;
    if (i2 > -1) {
      let x = o.slice(i2, o.lastIndexOf("}", i2)).match(/(passive|once)/g);
      x !== null && (x.indexOf("once") > -1 && (s.options.once = true), x.indexOf("passive") > -1 && (s.options.passive = true)), f2 = o.slice(0, i2);
    }
    let l2 = Ze(f2);
    l2.length > 1 && p(3, `No more than 1 DOM Event listener method allowed in value: ${o}`);
    let [u2, d] = l2[0].split("."), y = ut(u2, r);
    s.listener = c2, s.method = d.trim(), y.events[s.key] = s, re(e2, y.key, s.key);
  }
  function Mr(e2, t2, o) {
    for (let r of Ze(t2)) {
      let [s, i2] = r.split("."), a2 = ut(s, o), c2 = re(e2, a2.key, `n.${W()}`);
      a2.nodes[c2] = m({ key: c2, keyProp: i2, dom: o.t, schema: `${i2}Node`, isChild: a2.mounted });
    }
  }
  function qr(e2, t2, o) {
    for (let r of Ze(t2)) {
      let [s, i2] = r.split("."), a2 = ut(s, o), c2 = re(e2, a2.key, `b.${W()}`);
      i2 in a2.binds || (a2.binds[i2] = m()), a2.binds[i2][c2] = m({ key: c2, stateKey: i2, value: e2.innerText, dom: o.t, stateAttr: `${n.config.schema}${s}:${i2}`, selector: `[${n.qs.e}*=${go(c2)}]`, isChild: a2.mounted });
    }
  }
  function Ho(e2, t2, o, r) {
    o === null && r === null && (t2.t = W(), t2.n.push(t2.t), n.components.elements.set(t2.t, e2));
    for (let s = e2.attributes.length - 1; s >= 0; s--) {
      let { name: i2, value: a2 } = e2.attributes[s];
      if (o) {
        let c2 = `${n.config.schema}${o}:`;
        r && !i2.startsWith(c2) && (c2 = `${n.config.schema}${r}:`), i2.startsWith(c2) && (ut(o, t2).state[i2.slice(c2.length)] = a2);
      }
      i2.indexOf("@") > -1 ? Sr(e2, i2, a2, t2) : i2 === n.qs.E ? qr(e2, a2, t2) : i2 === n.qs.y && Mr(e2, a2, t2);
    }
  }
  function wr(e2, t2, o) {
    let { registry: r, elements: s } = n.components, { p: i2, f: a2 } = o, c2 = e2.hasAttribute("id") ? e2.id.trim() : null;
    o.t = W(), o.n.push(o.t), s.set(o.t, e2);
    for (let f2 of Or(t2))
      if (!r.has(f2))
        p(5, `Component does not exist in registry: ${f2}`);
      else {
        let l2;
        f2 in i2 ? (l2 = Ae(i2[f2]), l2.mounted === false ? (re(e2, l2.key, l2.ref), l2.dom = o.t, l2.mounted = true, l2.inFragment = qt(e2)) : i2[f2].push(wt(f2, e2, o))) : i2[f2] = [wt(f2, e2, o)], l2 = Ae(i2[f2]), c2 && !(c2 in a2) && (a2[c2] = f2), Ho(e2, o, f2, l2.alias);
      }
  }
  function dt(e2) {
    let t2 = mt();
    if (e2)
      if (e2 instanceof Set) {
        for (let o of e2)
          Re(o, t2);
        return e2.clear(), t2;
      } else
        return Re(e2, t2), t2;
    else {
      if (Ve(A(), (o) => Re(o, t2)), Ne(t2.p))
        return;
      ft(t2);
    }
  }
  var P;
  function ko() {
    H(() => {
      P = void 0;
    });
  }
  function Ht(e2, t2, o) {
    let { reference: r, connected: s, elements: i2 } = n.components;
    for (let a2 of t2) {
      let c2 = r[a2];
      if (!c2)
        continue;
      let f2 = a2.charCodeAt(0);
      if (f2 === 99) {
        c2.scope.mounted = false, s.delete(c2.scope.key), i2.delete(c2.scope.dom);
        let { scope: l2 } = c2;
        for (let u2 in l2.nodes)
          i2.delete(l2.nodes[u2].dom);
        for (let u2 in l2.binds)
          for (let d in l2.binds[u2])
            i2.delete(l2.binds[u2][d].dom);
        for (let u2 in l2.events)
          Fe(c2, l2.events[u2]);
        p(1, `Unmounted component ${c2.static.id} (${l2.key})`, "#8f5150");
      } else if (f2 === 101)
        Fe(c2, c2.scope.events[a2]);
      else if (f2 === 110) {
        let l2 = c2.scope.nodes[a2];
        o && e2.isEqualNode(o) ? (re(e2, c2.scope.key, a2), P.n.push(l2.dom)) : i2.delete(l2.dom);
      } else if (f2 === 98) {
        let { binds: l2 } = c2.scope;
        for (let u2 in l2)
          if (a2 in l2[u2]) {
            o && e2.isEqualNode(o) ? (re(e2, c2.scope.key, a2), P.n.push(l2[u2][a2].dom)) : i2.delete(l2[u2][a2].dom);
            break;
          }
      }
    }
  }
  function kt(e2, t2) {
    let { reference: o, connected: r, elements: s } = n.components;
    for (let i2 of t2) {
      let a2 = o[i2];
      if (!a2)
        continue;
      let c2 = i2.charCodeAt(0);
      if (c2 === 99)
        r.add(a2.scope.key), s.set(a2.scope.dom, e2), a2.scope.mounted = true, p(1, `Mounted component ${a2.static.id} (${a2.scope.key})`, "#6dd093");
      else if (c2 === 101)
        it(a2, e2, a2.scope.events[i2]);
      else if (c2 === 110)
        s.set(a2.scope.nodes[i2].dom, e2);
      else if (c2 === 98) {
        let { binds: f2 } = a2.scope;
        for (let l2 in f2)
          if (i2 in f2[l2]) {
            e2.innerText = f2[l2][i2].value, s.set(f2[l2][i2].dom, e2);
            break;
          }
      }
    }
  }
  function Xe(e2) {
    e2.nodeType !== 1 && e2.nodeType !== 11 || e2.hasAttribute(n.qs.e) && Ht(e2, e2.getAttribute(n.qs.e).split(","));
  }
  function Do(e2) {
    e2.hasAttribute(n.qs.e) ? kt(e2, e2.getAttribute(n.qs.e).split(",")) : oe(e2.attributes) && (P ? P.c = e2 : P = mt(e2), Re(e2, P));
  }
  function Wo(e2, t2, o, r) {
    if (o && (o = o.split(",")), r && (r = r.split(",")), o && r)
      Ht(e2, o), kt(e2, r);
    else if (!o && r)
      kt(e2, r);
    else {
      if (P ? P.c = t2 : P = mt(t2), o && !r && (Ht(e2, o, t2), e2.hasAttribute(n.qs.e)))
        return;
      Re(e2, P);
    }
  }
  function gt(e2, t2, o) {
    e2[o] !== t2[o] && (e2[o] = t2[o], e2[o] ? e2.setAttribute(o, v) : e2.removeAttribute(o));
  }
  function Fo(e2, t2) {
    if (t2.nodeType === 11 || e2.nodeType === 11)
      return;
    let o = t2.attributes, r = e2.getAttribute(n.qs.e), s = t2.getAttribute(n.qs.e), i2 = false, a2, c2, f2, l2, u2;
    for (let y = o.length - 1; y >= 0; y--)
      a2 = o[y], c2 = a2.name, l2 = a2.value, f2 = a2.namespaceURI, f2 ? (c2 = a2.localName || c2, u2 = e2.getAttributeNS(f2, c2), u2 !== l2 && (a2.prefix === "xmlns" && (c2 = a2.name), e2.setAttributeNS(f2, c2, l2))) : (u2 = e2.getAttribute(c2), u2 !== l2 && (e2.setAttribute(c2, l2), !r && !s && !i2 && (i2 = oe(c2))));
    let d = e2.attributes;
    for (let y = d.length - 1; y >= 0; y--)
      a2 = d[y], c2 = a2.name, l2 = a2.value, f2 = a2.namespaceURI, f2 ? (c2 = a2.localName || c2, t2.hasAttributeNS(f2, c2) || e2.removeAttributeNS(f2, c2)) : t2.hasAttribute(c2) || e2.removeAttribute(c2);
    (r || s || i2) && Wo(e2, t2, r, s);
  }
  function Xo(e2, t2) {
    let o = e2.parentNode;
    if (o) {
      let r = o.nodeName.toUpperCase();
      r === "OPTGROUP" && (o = o.parentNode, r = o && o.nodeName.toUpperCase()), r === "SELECT" && !o.hasAttribute("multiple") && (e2.hasAttribute("selected") && !t2.selected && (e2.setAttribute("selected", "selected"), e2.removeAttribute("selected")), o.selectedIndex = -1);
    }
    gt(e2, t2, "selected");
  }
  function jo(e2, t2) {
    gt(e2, t2, "checked"), gt(e2, t2, "disabled"), e2.value !== t2.value && (e2.value = t2.value), t2.hasAttribute("value") || e2.removeAttribute("value");
  }
  function Wt(e2, t2) {
    let { value: o } = t2;
    e2.value !== o && (e2.value = o);
    let { firstChild: r } = e2;
    if (r) {
      let { nodeValue: s } = r;
      if (s === o || !o && s === e2.placeholder)
        return;
      r.nodeValue = o;
    }
  }
  function Bo(e2, t2) {
    if (!t2.hasAttribute("multiple")) {
      let o = 0, r = -1, s = e2.firstElementChild, i2, a2;
      for (; s; )
        if (a2 = s.nodeName && s.nodeName.toUpperCase(), a2 === "OPTGROUP")
          i2 = s, s = i2.firstElementChild;
        else {
          if (a2 === "OPTION") {
            if (s.hasAttribute("selected")) {
              r = o;
              break;
            }
            o++;
          }
          s = s.nextElementSibling, !s && i2 && (s = i2.nextElementSibling, i2 = null);
        }
      e2.selectedIndex = r;
    }
  }
  function kr(e2, t2) {
    return !t2 || t2 === "http://www.w3.org/1999/xhtml" ? document.createElement(e2) : document.createElementNS(t2, e2);
  }
  function ht(e2, t2) {
    if (e2 === t2)
      return true;
    let o = e2.charCodeAt(0), r = t2.charCodeAt(0);
    return o <= 90 && r >= 97 ? e2 === t2.toUpperCase() : r <= 90 && o >= 97 ? t2 === e2.toUpperCase() : false;
  }
  function Dr(e2, t2) {
    switch (e2.nodeName) {
      case "INPUT":
        jo(e2, t2);
        break;
      case "OPTION":
        Xo(e2, t2);
        break;
      case "SELECT":
        Bo(e2, t2);
        break;
      case "TEXTAREA":
        Wt(e2, t2);
        break;
    }
  }
  function ne(e2) {
    return e2 && "getAttribute" in e2 ? e2.getAttribute("id") : void 0;
  }
  function Wr(e2, t2) {
    let o = e2.firstChild, r;
    for (; o; )
      r = o.nextSibling, t2.appendChild(o), o = r;
    return t2;
  }
  function yt(e2, t2, o, r = true) {
    Xe(e2), t2 && t2.removeChild(e2), Yo(e2, r, o);
  }
  function Vr(e2, t2, o) {
    let r = t2.firstChild, s, i2, a2 = e2.firstChild, c2, f2, l2, u2;
    e:
      for (; r; ) {
        for (s = ne(r), i2 = r.nextSibling; a2; ) {
          if (l2 = a2.nextSibling, r.isEqualNode(a2)) {
            r = i2, a2 = l2;
            continue e;
          }
          c2 = ne(a2), f2 = a2.nodeType;
          let d;
          if (f2 === r.nodeType && (f2 === 1 ? (s ? s !== c2 && ((u2 = o.s.get(s)) ? l2.isEqualNode(u2) ? d = false : (e2.insertBefore(u2, a2), c2 ? o.i.add(c2) : yt(a2, e2, o), a2 = u2, c2 = ne(a2)) : d = false) : c2 && (d = false), d = d !== false && ht(a2.nodeName, r.nodeName), d && Et(a2, r, o)) : (f2 === 3 || f2 === 8) && (d = true, a2.nodeValue !== r.nodeValue && (a2.nodeValue = r.nodeValue))), d) {
            r = i2, a2 = l2;
            continue e;
          }
          c2 ? o.i.add(c2) : yt(a2, e2, o), a2 = l2;
        }
        s && (u2 = o.s.get(s)) && ht(u2.nodeName, r.nodeName) ? (e2.appendChild(u2), Et(u2, r, o)) : (r.actualize && (r = r.actualize(e2.ownerDocument || document)), e2.appendChild(r), Vt(r, o)), r = i2, a2 = l2;
      }
    Fr(e2, a2, c2, o), Dr(e2, t2);
  }
  function Et(e2, t2, o) {
    let r = ne(t2);
    if (r && o.s.delete(r), e2.isEqualNode(t2))
      return;
    let s = e2.getAttribute(n.qs.c);
    s !== "false" && (s !== "children" && Fo(e2, t2), e2.nodeName !== "TEXTAREA" ? Vr(e2, t2, o) : Wt(e2, t2));
  }
  function Yo(e2, t2, o) {
    if (e2.nodeType !== 1)
      return;
    let r = e2.firstChild;
    for (; r; ) {
      let s;
      t2 && (s = ne(r)) ? o.i.add(s) : (Xe(r), r.firstChild && Yo(r, t2, o)), r = r.nextSibling;
    }
  }
  function Vt(e2, t2) {
    (e2.nodeType === 1 || e2.nodeType === 11) && Do(e2);
    let o = e2.firstChild;
    for (; o; ) {
      let r = o.nextSibling, s = ne(o);
      if (s) {
        let i2 = t2.s.get(s);
        i2 && ht(o.nodeName, i2.nodeName) ? (o.parentNode.replaceChild(i2, o), Et(i2, o, t2)) : Vt(o, t2);
      } else
        Vt(o, t2);
      o = r;
    }
  }
  function Fr(e2, t2, o, r) {
    for (; t2; ) {
      let s = t2.nextSibling;
      (o = ne(t2)) ? r.i.add(o) : yt(t2, e2, r), t2 = s;
    }
  }
  function Ko(e2, t2) {
    if (e2.nodeType === 1 || e2.nodeType === 11) {
      let o = e2.firstChild;
      for (; o; ) {
        let r = ne(o);
        r && t2.s.set(r, o), Ko(o, t2), o = o.nextSibling;
      }
    }
  }
  function G(e2, t2) {
    let o = t2.cloneNode(true), r = m({ i: Y(), s: U() });
    o.nodeType === 11 && (o = o.firstElementChild), Ko(e2, r);
    let s = e2, i2 = s.nodeType, a2 = o.nodeType;
    if (i2 === 1)
      a2 === 1 ? ht(e2.nodeName, o.nodeName) || (Xe(e2), s = Wr(e2, kr(o.nodeName, o.namespaceURI))) : s = o;
    else if (i2 === 3 || i2 === 8) {
      if (a2 === i2)
        return s.nodeValue !== o.nodeValue && (s.nodeValue = o.nodeValue), s;
      s = o;
    }
    if (s.isEqualNode(o))
      Xe(e2);
    else {
      if (o.isEqualNode(s))
        return s;
      if (Et(s, o, r), r.i.size > 0) {
        for (let c2 of r.i)
          if (r.s.has(c2)) {
            let f2 = r.s.get(c2);
            yt(f2, f2.parentNode, r, false);
          }
      }
    }
    return s !== e2 && e2.parentNode && (s.actualize && (s = s.actualize(e2.ownerDocument || document)), e2.parentNode.replaceChild(s, e2)), r.s.clear(), r.i.clear(), s;
  }
  function je(e2, t2) {
    if (!(e2 instanceof Element))
      return false;
    let o = e2.closest(t2);
    return o && o.tagName === "A" ? o : false;
  }
  function Uo(e2) {
    if (e2.nodeName !== "A")
      return false;
    let t2 = e2.getAttribute("href");
    return !t2 || !Ft(t2) ? false : q(j(t2)) === false;
  }
  function _o(e2, t2) {
    let o = [];
    return ee(e2, (r) => {
      if (r.nodeName !== "A") {
        let s = r.querySelectorAll(t2);
        ee(s, (i2) => {
          Uo(i2) && o.push(i2);
        });
      } else if (r.hasAttribute("href")) {
        let { href: s } = r;
        Ft(s) && q(j(s)) && o.push(r);
      }
    }), o;
  }
  var Be = (e2) => {
    let t2 = [];
    return ee(e2, (o) => {
      Uo(o) && t2.push(o);
    }), t2;
  };
  function zo(e2) {
    let t2 = je(e2.target, n.qs.l);
    if (!t2)
      return;
    let o = I(t2, 10);
    if (q(o.key) || o.key in E.r)
      return;
    t2.addEventListener(`${M}leave`, Go, { once: true });
    let r = C(o), s = r.threshold || n.config.hover.threshold;
    nt(o.key, function() {
      L("prefetch", t2, o) && $(r).then(function() {
        delete E.r[o.key], Jo(t2);
      });
    }, s);
  }
  function Go(e2) {
    let t2 = je(e2.target, n.qs.l);
    t2 && rt(j(t2.href));
  }
  function Xr(e2) {
    e2.addEventListener(`${M}enter`, zo);
  }
  function Jo(e2) {
    e2.removeEventListener(`${M}enter`, zo), e2.removeEventListener(`${M}leave`, Go);
  }
  function Ye() {
    !n.config.hover || n.observe.hover || (B(Xr, Be(n.qs.l)), n.observe.hover = true);
  }
  function he() {
    n.observe.hover && (B(Jo, Be(n.qs.l)), n.observe.hover = false);
  }
  var ye;
  function jr(e2) {
    return __async(this, null, function* () {
      if (e2.isIntersecting) {
        let t2 = I(e2.target, 11);
        if (!L("prefetch", e2.target, t2))
          return ye.unobserve(e2.target);
        (yield $(C(t2))) ? ye.unobserve(e2.target) : (p(3, `Prefetch will retry at next intersect for: ${t2.key}`), ye.observe(e2.target));
      }
    });
  }
  function Ke() {
    if (!n.config.intersect || n.observe.intersect)
      return;
    ye || (ye = new IntersectionObserver(B(jr), n.config.intersect));
    let e2 = B((o) => ye.observe(o)), t2 = _o(n.qs.I, n.qs.L);
    e2(t2), n.observe.intersect = true;
  }
  function Ee() {
    n.observe.intersect && (ye.disconnect(), n.observe.intersect = false);
  }
  var Ue = {};
  Er(Ue, { connect: () => ie, disconnect: () => $e, hook: () => se, teardown: () => ve });
  function ve() {
    for (let e2 in n.components.reference)
      delete n.components.reference[e2];
    for (let e2 of n.components.instances.values())
      for (let t2 in e2.scope.events)
        Fe(e2, e2.scope.events[t2]);
    n.components.elements.clear(), n.components.instances.clear(), n.components.connected.clear(), p(2, "Component instances were disconnected");
  }
  function se(e2, t2) {
    if (e2 === "onvisit")
      return H(() => se(null, t2));
    e2 === null && (e2 = "onvisit");
    let { connected: o, instances: r } = n.components;
    e2 === "onload" && K("components", ro(o));
    for (let s of o) {
      let i2 = r.get(s);
      i2 && e2 in i2 && i2[e2].apply(i2, t2);
    }
  }
  function ie() {
    n.observe.components || (n.page.type === 0 ? dt() : (P && (ft(P), ko()), se("onload", [n.page])), n.observe.components = true);
  }
  function $e() {
    n.observe.components && (se("onexit", [n.page]), n.observe.components = false);
  }
  var vt = new MutationObserver(function([e2]) {
    if (e2.type !== "childList")
      return;
    let t2 = e2.addedNodes.length;
    if (t2 || e2.removedNodes.length > 0) {
      let [o] = t2 ? e2.addedNodes : e2.removedNodes;
      if (o.nodeType !== 1)
        return;
      n.eval && lo.test(o.nodeName) ? o.parentNode.nodeName === "HEAD" ? t2 ? Mt("appendChild", o) : Mt("removeChild", o) : Br(o) && !n.resources.has(o) ? n.resources.add(o) : n.resources.delete(o) : o instanceof HTMLElement && t2 && !o.hasAttribute(n.qs.e) && dt(o);
    }
  });
  function Br(e2) {
    let t2 = A().querySelectorAll(`${n.page.target.join(",")},[${n.qs.m}]`);
    for (let o = 0, r = t2.length; o < r; o++)
      if (t2[o].contains(e2))
        return false;
    return true;
  }
  function _e() {
    n.observe.mutations || (vt.observe(document.head, { childList: true }), vt.observe(A(), { childList: true, subtree: true }), n.observe.mutations = true);
  }
  function ze() {
    if (n.observe.mutations) {
      vt.takeRecords(), vt.disconnect();
      for (let e2 of n.resources)
        A().removeChild(e2), n.resources.delete(e2);
      n.observe.mutations = false;
    }
  }
  function Yr({ clientX: e2, clientY: t2 }, o) {
    return e2 <= o.right && e2 >= o.left && t2 <= o.bottom && t2 >= o.top;
  }
  function Kr(e2) {
    let t2 = e2.getBoundingClientRect(), o = e2.getAttribute(n.qs.v), r = Je.test(o) ? Number(o) : n.config.proximity.distance;
    return { target: e2, top: t2.top - r, bottom: t2.bottom + r, left: t2.left - r, right: t2.right + r };
  }
  function Ur(e2) {
    let t2 = false;
    return (o) => {
      if (t2)
        return;
      t2 = true;
      let r = e2.findIndex((s) => Yr(o, s));
      if (r === -1)
        setTimeout(() => {
          t2 = false;
        }, n.config.proximity.throttle);
      else {
        let { target: s } = e2[r], i2 = C(I(s, 12)), a2 = i2.threshold || n.config.proximity.threshold;
        nt(i2.key, () => __async(this, null, function* () {
          if (!L("prefetch", s, i2))
            return J();
          (yield $(i2)) && (e2.splice(r, 1), t2 = false, e2.length === 0 && (J(), p(2, "Proximity observer disconnected")));
        }), a2);
      }
    };
  }
  var Bt;
  function Ge() {
    if (!n.config.proximity || n.observe.proximity)
      return;
    let e2 = Be(n.qs.v).map(Kr);
    e2.length > 0 && (Bt = Ur(e2), addEventListener(`${M}move`, Bt, { passive: true }), n.observe.proximity = true);
  }
  function J() {
    n.observe.proximity && (removeEventListener(`${M}move`, Bt), n.observe.proximity = false);
  }
  function _r(e2, t2) {
    return __async(this, null, function* () {
      if (!n.eval || !e2 || !t2)
        return;
      let o = [], r = Y(), { children: s } = e2;
      for (let c2 = 0, f2 = t2.length; c2 < f2; c2++)
        r.add(t2[c2].outerHTML);
      for (let c2 = 0, f2 = s.length; c2 < f2; c2++) {
        let l2 = s[c2], { nodeName: u2, outerHTML: d } = l2, y = true;
        u2 === "SCRIPT" ? y = l2.matches(n.qs.P) : u2 === "STYLE" ? y = l2.matches(n.qs.N) : u2 === "META" ? y = l2.matches(n.qs.R) : u2 === "LINK" ? y = l2.matches(n.qs.C) : y = e2.getAttribute(n.qs.b) !== "false", r.has(d) ? y ? o.push(l2) : r.delete(d) : o.push(l2);
      }
      let i2 = [], a2 = document.createRange();
      for (let c2 of r) {
        let f2 = a2.createContextualFragment(c2).firstChild;
        if (T(f2, "href") || T(f2, "src")) {
          let u2 = new Promise(function(d) {
            f2.addEventListener("error", (y) => {
              p(3, `Resource <${f2.nodeName.toLowerCase()}> failed:`, f2), d();
            }), f2.addEventListener("load", () => d());
          });
          i2.push(u2);
        }
        e2.appendChild(f2), r.delete(c2);
      }
      for (let c2 = 0, f2 = o.length; c2 < f2; c2++)
        e2.removeChild(o[c2]);
      yield Promise.all(i2);
    });
  }
  function zr(e2, t2) {
    let o = A();
    if (e2.selector === "body")
      G(o, t2.body);
    else if (e2.selector !== null) {
      let r = o.querySelectorAll(e2.selector), s = t2.body.querySelectorAll(e2.selector), i2 = Y();
      for (let a2 = 0, c2 = r.length; a2 < c2; a2++) {
        let f2 = r[a2], l2 = s[a2];
        !l2 || !f2 || L("render", f2, l2) && (f2.isEqualNode(l2) || i2.add(G(f2, l2)));
      }
      e2.type !== 6 && P && P.n.length > 0 && H(() => {
        St(t2.body, o, P.n, i2), K("type", 6), i2.clear();
      });
    } else
      for (let r of e2.fragments) {
        let s = n.fragments.get(r), i2 = t2.getElementById(r);
        !i2 || !s || L("render", s, i2) && (s.isEqualNode(i2) || (G(s, i2), P && P.n.length > 0 && H(() => at(i2, P.n))));
      }
  }
  function Gr(e2, t2) {
    let o = e2.hydrate;
    if (o.length === 1 && o[0] === "body") {
      G(A(), t2.body);
      return;
    }
    let r = o.join(","), s = A().querySelectorAll(r), i2 = e2.preserve && e2.preserve.length > 0 ? e2.preserve.join(",") : null, a2 = [];
    if (i2) {
      let c2 = A().querySelectorAll(i2);
      for (let f2 = 0, l2 = c2.length; f2 < l2; f2++) {
        let u2 = c2[f2];
        u2.setAttribute(n.qs.c, "false"), a2.push(u2);
      }
    }
    if (s.length > 0) {
      let c2 = t2.body.querySelectorAll(r);
      for (let f2 = 0, l2 = s.length; f2 < l2; f2++) {
        let u2 = s[f2], d = c2[f2];
        if (c2[f2] instanceof HTMLElement) {
          if (!L("hydrate", u2, d))
            continue;
          G(d, d);
        }
      }
    }
    if (i2)
      for (let c2 of a2)
        c2.removeAttribute("spx-morph");
    e2.hydrate = void 0, e2.preserve = void 0, e2.type = 6, k(e2);
  }
  function k(e2) {
    he(), Ee(), J(), ze(), $e(), lt(), n.eval || (document.title = e2.title);
    let t2 = z(e2.snap);
    return e2.type === 7 ? Gr(e2, t2) : (_r(so(), t2.head.children), zr(e2, t2), scrollTo(e2.scrollX, e2.scrollY)), me.done(), H(() => {
      Ye(), Ke(), Ge(), ie(), _e();
    }), L("load", e2), e2;
  }
  var g = window.history;
  function Qo() {
    return g.state !== null && "rev" in g.state && g.state.key !== g.state.rev;
  }
  function Ut(e2) {
    if (g.state == null || typeof g.state != "object")
      return false;
    let t2 = Pe(g.state)(["key", "rev", "scrollX", "scrollY", "title"]);
    return typeof e2 == "string" ? t2 && g.state.key === e2 : t2;
  }
  function er() {
    return __async(this, null, function* () {
      yield Eo(), n.loaded = true;
    });
  }
  function Jr(e2) {
    return Ut(e2.key) ? (scrollTo(g.state.scrollX, g.state.scrollY), R(e2, g.state)) : xe(e2), e2;
  }
  function xe({ key: e2, rev: t2, title: o, scrollX: r, scrollY: s }) {
    let i2 = { key: e2, rev: t2, scrollX: r, scrollY: s, title: o || document.title };
    return g.replaceState(i2, i2.title, i2.key), p(1, `History replaceState: ${g.state.key}`), g.state;
  }
  function Te({ key: e2, rev: t2, title: o }) {
    let r = { key: e2, rev: t2, title: o, scrollY: 0, scrollX: 0 };
    return g.pushState(r, r.title, r.key), p(1, `History pushState: ${g.state.key}`), g.state;
  }
  function tr(e2) {
    return __async(this, null, function* () {
      if ((n.loaded || n.ready) && e2.state !== null)
        if (q(e2.state.key)) {
          !q(e2.state.rev) && e2.state.rev !== e2.state.key && st(e2.state.rev);
          let t2 = n.pages[e2.state.key];
          t2.type === 4 ? (p(1, `History popState reverse (snapshot): ${t2.key}`), ve()) : p(1, `History popState session (snapshot): ${t2.key}`), K("type", 5), k(t2);
        } else {
          p(1, `History popState fetch: ${e2.state.key}`), ve(), e2.state.type = 5;
          let t2 = yield $(e2.state);
          if (!t2)
            return location.assign(e2.state.key);
          let o = j(location);
          if (t2.key === o)
            k(t2);
          else if (q(o))
            k(n.pages[o]);
          else {
            ve();
            let r = C(I(o, 5));
            yield $(r), Te(r);
          }
        }
    });
  }
  function or(e2) {
    if (!n.observe.history)
      return g.scrollRestoration && (g.scrollRestoration = "manual"), addEventListener("popstate", tr, false), addEventListener("load", er, false), n.observe.history = true, typeof e2 == "object" && e2.type === 0 ? Jr(e2) : e2;
  }
  function rr() {
    n.observe.history && (g.scrollRestoration && (g.scrollRestoration = "auto"), removeEventListener("popstate", tr, false), removeEventListener("load", er, false), n.observe.history = false);
  }
  function C(e2) {
    let t2 = Pe(e2);
    return e2.ts = Qe(), e2.target = Rt(e2), t2("selector") || (e2.target[0] === "body" ? e2.selector = "body" : e2.selector = we(e2.target)), n.config.cache && (t2("cache") || (e2.cache = n.config.cache), t2("snap") || (e2.snap = W())), t2("scrollY") || (e2.scrollY = 0), t2("scrollX") || (e2.scrollX = 0), n.config.hover !== false && e2.type === 10 && (t2("threshold") || (e2.threshold = n.config.hover.threshold)), n.config.proximity !== false && e2.type === 12 && (t2("proximity") || (e2.proximity = n.config.proximity.distance), t2("threshold") || (e2.threshold = n.config.proximity.threshold)), n.config.progress && !t2("progress") && (e2.progress = n.config.progress.threshold), t2("fragments") || (e2.fragments = n.config.fragments), t2("history") || (e2.history = true), t2("visits") || (e2.visits = 0), t2("components") || (e2.components = []), n.pages[e2.key] = e2, n.pages[e2.key];
  }
  function nr(e2) {
    let t2 = R(m(e2), { target: [], selector: null, cache: n.config.cache, history: true, scrollX: 0, scrollY: 0, fragments: n.config.fragments });
    return n.config.hover && (t2.threshold = n.config.hover.threshold), n.config.proximity && (t2.proximity = n.config.proximity.distance, t2.threshold = n.config.proximity.threshold), n.config.progress && (t2.progress = n.config.progress.threshold), t2;
  }
  function K(e2, t2, o = g.state.key) {
    return e2 === "location" ? n.pages[o][e2] = R(n.pages[o][e2], t2) : e2 === "target" ? (n.pages[o].target = Rt(t2), n.pages[o].selector = we(n.pages[o].target)) : e2 === "components" ? n.pages[o].components = t2 : n.pages[o][e2] = t2, n.pages[o];
  }
  function Ce(e2, t2) {
    let o = L("before:cache", e2, t2), r = typeof o == "string" ? o : t2;
    return e2.type > 5 && e2.type > 9 && (e2.type = 1), e2.title = Lt(t2), !n.config.cache || o === false ? e2 : "snap" in e2 ? (n.pages[e2.key] = e2, n.snaps[e2.snap] = r, wo(e2), L("after:cache", e2), se("oncache", e2), e2) : ae(e2, r);
  }
  function ae(e2, t2) {
    let o = e2.key in n.pages ? n.pages[e2.key] : C(e2);
    return typeof t2 == "string" && (n.snaps[o.snap] = t2, e2.title = Lt(t2)), R(o, e2);
  }
  function ct(e2, t2) {
    let o = t2 = t2 ? t2.charCodeAt(0) === 47 ? t2 in n.pages ? n.pages[t2].snap : null : t2 : n.page.snap;
    o ? n.snaps[o] = e2 : p(3, "Snapshot record does not exist, update failed");
  }
  function Mo(e2) {
    if (!e2) {
      if (g.state === null) {
        p(3, "Missing history state reference, page cannot be returned");
        return;
      }
      e2 = g.state.key;
    }
    if (e2 in n.pages)
      return X(m(), { page: { get: () => n.pages[e2] }, dom: { get: () => ue(n.snaps[n.pages[e2].snap]) } });
    p(5, `No record exists: ${e2}`);
  }
  function z(e2) {
    let t2 = e2 = e2 ? e2.charCodeAt(0) === 47 ? n.pages[e2].snap : e2 : n.page.snap;
    return ue(n.snaps[t2]);
  }
  function qo({ mounted: e2 = null } = {}) {
    let t2 = m();
    for (let o of n.components.instances.values()) {
      let { scope: r } = o;
      n.components.connected.has(r.key) && (e2 !== null && r.mounted === e2 || (r.alias !== null && !(r.alias in t2) ? t2[r.alias] = [o] : r.instanceOf in t2 ? t2[r.instanceOf].push(o) : t2[r.instanceOf] = [o]));
    }
    return Ne(t2) ? null : t2;
  }
  function sr(e2) {
    if (!e2) {
      if (g.state === null) {
        p(3, "Missing history state reference, page cannot be returned");
        return;
      }
      e2 = g.state.key;
    }
    if (e2 in n.pages)
      return n.pages[e2];
    p(5, `No page record exists for: ${e2}`);
  }
  function q(e2) {
    return T(n.pages, e2) && T(n.pages[e2], "snap") && T(n.snaps, n.pages[e2].snap) && typeof n.snaps[n.pages[e2].snap] == "string";
  }
  function Z(e2) {
    e2 ? typeof e2 == "string" ? (delete n.snaps[n.pages[e2].snap], delete n.pages[e2]) : O(e2) && B((t2) => {
      delete n.snaps[n.pages[t2].snap], delete n.pages[t2];
    }, e2) : ($t(n.pages), $t(n.snaps));
  }
  var w = le.replace(/(?:https?:)?(?:\/\/(?:www\.)?|(?:www\.))/, v);
  function Gt(e2, t2) {
    let o = t2 ? nr(t2) : m(), r = e2.getAttributeNames();
    for (let s = 0, i2 = r.length; s < i2; s++) {
      let a2 = r[s];
      if (a2.startsWith(n.qs.d)) {
        T(o, "data") || (o.data = m());
        let c2 = pe(a2.slice(n.qs.d.length)), f2 = e2.getAttribute(a2).trim();
        qe.test(f2) ? o.data[c2] = f2 === "NaN" ? NaN : +f2 : Me.test(f2) ? o.data[c2] = f2 === "true" : f2.charCodeAt(0) === 123 || f2.charCodeAt(0) === 91 ? o.data[c2] = Ie(a2, f2) : o.data[c2] = f2;
      } else {
        if (!n.qs.x.test(a2))
          continue;
        let c2 = e2.getAttribute(a2).trim();
        if (a2 === "href")
          o.rev = location.pathname + location.search, t2 || (o.location = zt(c2), o.key = o.location.pathname + o.location.search);
        else {
          let f2 = a2.slice(a2.lastIndexOf("-") + 1), l2 = c2.replace(co, v).trim();
          if (f2 === "target")
            o[f2] = l2 === "true" ? [] : l2 !== v ? uo(l2) : [], o.selector = we(o[f2]);
          else if (po.test(l2)) {
            let u2 = l2.match(/\[?[^,'"[\]()\s]+\]?/g);
            o[f2] = ao.test(f2) ? u2.reduce(To(2), []) : u2;
          } else if (f2 === "position")
            if (Ct.test(l2)) {
              let u2 = l2.match(Ct);
              o[`scroll${u2[0].toUpperCase()}`] = +u2[1], u2.length === 4 && (o[`scroll${u2[2].toUpperCase()}`] = +u2[3]);
            } else
              p(3, `Invalid attribute value on <${a2}>, expected: y:number or x:number`, e2);
          else
            f2 === "scroll" ? Je.test(l2) ? o.scrollY = +l2 : p(3, `Invalid attribute value on <${a2}>, expected: number`, e2) : Me.test(l2) && !fo.test(a2) ? o[f2] = l2 === "true" : qe.test(l2) ? o[f2] = +l2 : (f2 === "history" && l2 !== "push" && l2 !== "replace" && p(5, `Invalid attribute value on <${a2}>, expected: false, push or replace`, e2), o[f2] = l2);
        }
      }
    }
    return o;
  }
  function Le(e2) {
    let t2 = m();
    if (e2.length === 1 && e2.charCodeAt(0) === 47)
      return t2.pathname = e2, t2.hash = v, t2.search = v, t2;
    let r = e2.indexOf("#");
    r >= 0 ? (t2.hash = e2.slice(r), e2 = e2.slice(0, r)) : t2.hash = v;
    let s = e2.indexOf("?");
    return s >= 0 ? (t2.search = e2.slice(s), e2 = e2.slice(0, s)) : t2.search = v, t2.pathname = e2, t2;
  }
  function Tt(e2, t2) {
    let o = e2.indexOf("/", t2);
    if (o > t2) {
      let s = e2.indexOf("#", o);
      return s < 0 ? e2.slice(o) : e2.slice(o, s);
    }
    let r = e2.indexOf("?", t2);
    if (r > t2) {
      let s = e2.indexOf("#", r);
      return s < 0 ? e2.slice(r) : e2.slice(r, s);
    }
    return e2.length - t2 === w.length ? "/" : null;
  }
  function _t(e2) {
    let t2 = e2.startsWith("www.") ? e2.slice(4) : e2, o = t2.indexOf("/");
    if (o >= 0) {
      let r = t2.slice(o);
      if (t2.slice(0, o) === w)
        return r.length > 0 ? Le(r) : Le("/");
    } else {
      let r = t2.search(/[?#]/);
      if (r >= 0) {
        if (t2.slice(0, r) === w)
          return Le("/" + t2.slice(r));
      } else if (t2 === w)
        return Le("/");
    }
    return null;
  }
  function Zr(e2) {
    return e2.startsWith("http") ? 1 : e2.startsWith("//") ? 2 : e2.startsWith("www.") ? 3 : 0;
  }
  function Ft(e2) {
    if (typeof e2 != "string" || e2.length === 0)
      return false;
    if (e2.charCodeAt(0) === 47)
      return e2.charCodeAt(1) !== 47 ? true : e2.startsWith("www.", 2) ? e2.startsWith(w, 6) : e2.startsWith(w, 2);
    if (e2.charCodeAt(0) === 63)
      return true;
    if (e2.startsWith("www."))
      return e2.startsWith(w, 4);
    if (e2.startsWith("http")) {
      let t2 = e2.indexOf("/", 4) + 2;
      return e2.startsWith("www.", t2) ? e2.startsWith(w, t2 + 4) : e2.startsWith(w, t2);
    }
  }
  function Qr(e2) {
    return e2.charCodeAt(0) === 47 ? e2.charCodeAt(1) !== 47 ? Le(e2) : _t(e2.slice(2)) : e2.charCodeAt(0) === 63 ? Le(location.pathname + e2) : e2.startsWith("https:") || e2.startsWith("http:") ? _t(e2.slice(e2.indexOf("/", 4) + 2)) : e2.startsWith("www.") ? _t(e2) : null;
  }
  function j(e2) {
    if (typeof e2 == "object")
      return e2.pathname + e2.search;
    if (e2 === v)
      return "/";
    let t2 = Zr(e2);
    if (t2 === 1) {
      let o = e2.charCodeAt(4) === 115 ? 8 : 7, r = e2.startsWith("www.", o) ? o + 4 : o;
      return e2.startsWith(w, r) ? Tt(e2, r) : null;
    }
    if (t2 === 2) {
      let o = e2.startsWith("www.", 2) ? 6 : 2;
      return e2.startsWith(w, o) ? Tt(e2, o) : null;
    }
    return t2 === 3 ? e2.startsWith(w, 4) ? Tt(e2, 4) : null : e2.startsWith(w, 0) ? Tt(e2, 0) : null;
  }
  function ir() {
    return m({ hostname: w, origin: le, pathname: location.pathname, search: location.search, hash: location.hash });
  }
  function zt(e2) {
    if (e2 === v)
      return ir();
    let t2 = Qr(e2);
    return t2 === null && p(5, `Invalid pathname: ${e2}`), t2.origin = le, t2.hostname = w, t2;
  }
  function I(e2, t2 = 6) {
    if (e2 instanceof Element) {
      let r = Gt(e2);
      return r.type = t2 || 6, r;
    }
    let o = m();
    return e2 === 0 ? (o.location = ir(), o.key = o.rev = j(o.location), o.type = e2, o.visits = 1, n.index = o.key) : t2 === 7 ? (o.location = zt(e2), o.key = o.rev = j(o.location), o.type = t2) : (o.rev = location.pathname + location.search, o.location = zt(typeof e2 == "string" ? e2 : o.rev), o.key = j(o.location), o.type = t2), o;
  }
  function en(e2) {
    return !(e2.target && e2.target.isContentEditable || e2.defaultPrevented || e2.button > 1 || e2.altKey || e2.ctrlKey || e2.metaKey || e2.shiftKey);
  }
  var F = function(e2) {
    if (!en(e2))
      return;
    let t2 = je(e2.target, n.qs.A);
    if (!t2)
      return;
    let o = j(t2.href);
    if (o === null)
      return;
    let r = o === n.page.key;
    console.log(o, n.page.key, n.prev.key);
    let s = () => {
      p(3, `Drag occurance deteced, cancelled visit: ${o}`), F.drag = true, t2.removeEventListener(`${M}move`, s);
    };
    if (t2.addEventListener(`${M}move`, s, { once: true }), F.drag === true)
      return F.drag = false, F(e2);
    if (t2.removeEventListener(`${M}move`, s), !L("visit", e2))
      return;
    let i2 = (a2, c2 = true) => {
      n.pages[a2.key].ts = Qe(), n.pages[a2.key].visits = a2.visits + 1, n.pages[a2.rev].scrollX = window.scrollX, n.pages[a2.rev].scrollY = window.scrollY, se("onvisit", a2), r ? (p(1, `URL Pathname matches current route: ${o}`), k(a2)) : (xe(n.pages[a2.rev]), c2 ? (Te(a2), k(a2)) : ar(a2));
    };
    if (he(), J(), Ee(), q(o)) {
      let a2 = Gt(t2, n.pages[o]), c2 = ae(a2);
      t2.onclick = (f2) => {
        f2.preventDefault(), i2(c2);
      };
    } else if (E.a.has(o)) {
      Ot(o), p(2, `Request in transit: ${o}`);
      let a2 = n.pages[o];
      t2.onclick = (c2) => {
        c2.preventDefault(), i2(a2, false);
      };
    } else {
      Ot(), rt(o);
      let a2 = C(I(t2, 6));
      $(a2), t2.onclick = (c2) => {
        c2.preventDefault(), i2(a2, false);
      };
    }
  };
  function ar(e2) {
    return __async(this, null, function* () {
      e2.progress && me.start(e2.progress);
      let t2 = yield We(e2);
      t2 ? (Te(t2), k(t2)) : location.assign(e2.key);
    });
  }
  function Jt(e2, t2) {
    return __async(this, null, function* () {
      if (t2) {
        typeof t2.cache == "string" && (t2.cache === "clear" ? Z() : Z(t2.key)), t2.progress && me.start(t2.progress);
        let o = yield $(t2);
        o ? (Te(o), k(o)) : location.assign(t2.key);
      } else
        return ar(n.pages[e2]);
    });
  }
  function cr() {
    n.observe.hrefs || (F.drag = false, Oe === "mouseOnly" ? addEventListener(`${M}down`, F, false) : (Oe === "touchOnly" || addEventListener(`${M}down`, F, false), addEventListener("touchstart", F, false)), n.observe.hrefs = true);
  }
  function fr() {
    n.observe.hrefs && (Oe === "mouseOnly" ? removeEventListener(`${M}down`, F, false) : (Oe === "touchOnly" || removeEventListener(`${M}down`, F, false), removeEventListener("touchstart", F, false)), n.observe.hrefs = false);
  }
  function pr() {
    let e2 = I(0), t2 = or(C(e2));
    X(n, { prev: { get() {
      return n.pages[g.state.rev];
    } }, page: { get() {
      return n.pages[g.state.key];
    } }, snapDom: { get() {
      return ue(n.snaps[n.page.snap]);
    } } });
    let o = () => {
      let r = Ce(t2, de());
      return cr(), lt(), n.config.manual === false && (Ye(), Ke(), Ge(), ie(), _e()), H(() => {
        K("type", 6), st(r), Ro(r);
      }), r;
    };
    return new Promise((r) => {
      let { readyState: s } = document;
      if (s === "interactive" || s === "complete")
        return r(o());
      addEventListener("DOMContentLoaded", () => r(o()));
    });
  }
  function mr() {
    he(), Ye(), Ee(), Ke(), J(), Ge(), $e(), ie(), ze(), _e();
  }
  function ur() {
    rr(), fr(), ze(), he(), Ee(), J(), n.config.components && ($e(), ve(), n.components.registry.clear()), Z(), n.config.globalThis && delete window.spx, p(2, "Disconnected");
  }
  var dr = class {
    constructor(e2, t2) {
      this.state = m();
      X(this, { scope: { get() {
        return e2;
      } }, static: { get() {
        return t2;
      } } });
      let o = `${n.config.schema}${this.scope.instanceOf}`;
      if (console.log(e2), this.state = new Proxy(m(), { set: (r, s, i2) => {
        let a2 = this.static.state[s], c2 = typeof i2 == "object" || O(i2) ? JSON.stringify(i2) : `${i2}`;
        if (typeof a2 == "object" && T(a2, "persist") && a2.persist ? r[s] = this.scope.state[s] = i2 : r[s] = i2, this.dom && c2 !== this.dom.getAttribute(`${o}:${s}`) && this.dom.setAttribute(`${o}:${s}`, c2), s in this.scope.binds) {
          let { binds: f2 } = this.scope;
          for (let l2 in f2[s])
            f2[s][l2].value = c2, n.components.elements.has(f2[s][l2].dom) && (n.components.elements.get(f2[s][l2].dom).innerText = c2);
        }
        return true;
      } }), Ne(this.scope.state))
        for (let r in this.static.state) {
          let s = this.static.state[r], i2, a2;
          typeof s == "object" ? (i2 = s.typeof, a2 = s.default) : i2 = s, i2 === String ? this.state[r] = a2 || v : i2 === Boolean ? this.state[r] = a2 || false : i2 === Number ? this.state[r] = a2 ? +a2 : 0 : i2 === Array ? this.state[r] = a2 || [] : i2 === Object && (this.state[r] = a2 || {}), this.scope.state[r] = this.state[r];
        }
      else
        for (let r in t2.state) {
          if (!(r in this.scope.state))
            if (typeof t2.state[r] == "object")
              this.scope.state[r] = t2.state[r].default;
            else
              switch (t2.state[r]) {
                case String:
                  this.scope.state[r] = v;
                  break;
                case Boolean:
                  this.scope.state[r] = false;
                  break;
                case Number:
                  this.scope.state[r] = 0;
                  break;
                case Object:
                  this.scope.state[r] = {};
                  break;
                case Array:
                  this.scope.state[r] = [];
                  break;
              }
          let s = this.static.state[r], i2, a2 = this.dom.getAttribute(`${o}:${r}`), c2, f2 = a2 !== null && a2 !== v;
          typeof s == "object" ? (i2 = s.typeof, c2 = f2, f2 || (a2 = s.default)) : i2 = s, `has${He(r)}` in this.state || Q(this.state, `has${He(r)}`, { get() {
            return f2;
          } }), typeof a2 == "string" && a2.startsWith("window.") ? this.state[r] = window[a2.slice(7)] : i2 === String ? this.state[r] = a2 || v : i2 === Boolean ? this.state[r] = a2 || false : i2 === Number ? this.state[r] = a2 ? +a2 : 0 : i2 === Array ? this.state[r] = f2 ? Ie(a2) : c2 ? a2 : [] : i2 === Object && (this.state[r] = f2 ? Ie(a2) : c2 ? a2 : {}), this.scope.state[r] = this.state[r];
        }
    }
    get dom() {
      return n.components.elements.get(this.scope.dom);
    }
    get html() {
      return this.dom.closest("html");
    }
  };
  var Zt = m({ $: n, Component: dr, on: No, off: Co, observe: mr, connect: tn, capture: cn, form: ln, render: an, session: rn, reload: nn, fetch: sn, clear: Z, hydrate: pn, prefetch: fn, visit: mn, disconnect: ur, register: on, get config() {
    return n.config;
  }, supported: !!(At && window.history.pushState && window.requestAnimationFrame && window.DOMParser && window.Proxy), history: m({ get state() {
    return g.state;
  }, api: g, push: Te, replace: xe, has: Ut, reverse: Qo }) });
  function tn(e2 = {}) {
    if (At === false)
      return p(5, "Invalid runtime environment: window is undefined.");
    if (!Zt.supported)
      return p(5, "Browser does not support SPX");
    if (!window.location.protocol.startsWith("http"))
      return p(5, "Invalid protocol, SPX expects HTTPS or HTTP protocol");
    Po(e2), n.config.globalThis && T(window, "spx") === false && et(window, "spx", Zt);
    let t2 = pr();
    return function(o) {
      return __async(this, null, function* () {
        let r = yield t2;
        if (o.constructor.name === "AsyncFunction")
          try {
            yield o(r);
          } catch (s) {
            p(3, "Connection Error", s);
          }
        else
          o(r);
        p(2, "Connection Established");
      });
    };
  }
  function on(...e2) {
    if (typeof e2[0] == "string")
      e2.length > 2 && p(5, [`Named component registration expects 2 parameters, recieved ${e2.length}.`, 'Registry should follow this structure: spx.register("identifer", YourComponent)'], e2), te({ [Ue[0]]: e2[1] });
    else
      for (let t2 of e2)
        if (O(t2))
          for (let o of t2)
            typeof o[0] == "string" ? te({ [o[0]]: o[1] }) : typeof o == "function" && te({ [ot(o)]: o });
        else {
          let o = typeof t2;
          o === "function" ? te({ [ot(t2)]: t2 }) : o === "object" && te(t2);
        }
    n.ready && (n.config.components || (ie(), n.config.components = true));
  }
  function rn() {
    return X(m(), { config: { get() {
      return n.config;
    } }, snaps: { get() {
      return n.snaps;
    } }, pages: { get() {
      return n.pages;
    } }, observers: { get() {
      return n.observe;
    } }, components: { get() {
      return n.components;
    } }, fragments: { get() {
      return n.fragments;
    } }, memory: { get() {
      let e2 = n.memory;
      return e2.size = bo(e2.bytes), e2;
    } } });
  }
  function nn() {
    return __async(this, null, function* () {
      let e2 = n.pages[g.state.key];
      e2.type = 9;
      let t2 = yield $(e2);
      return t2 ? (p(2, "Triggered reload, page was re-cached"), k(t2)) : (p(3, "Reload failed, triggering refresh (cache will purge)"), location.assign(e2.key));
    });
  }
  function sn(e2) {
    return __async(this, null, function* () {
      let t2 = I(e2, 2);
      t2.location.origin !== le && p(5, "Cross origin fetches are not allowed");
      let o = yield De(t2.key);
      if (o)
        return o;
    });
  }
  function an(e2, t2, o) {
    return __async(this, null, function* () {
      let r = n.page, s = I(e2);
      s.location.origin !== le && p(5, "Cross origin fetches are not allowed");
      let i2 = yield De(s.key, { type: "document" });
      if (i2 || p(5, `Fetch failed for: ${s.key}`, i2), yield o.call(r, i2), t2 === "replace") {
        r.title = i2.title;
        let a2 = ae(R(r, s), de(i2));
        return xe(a2), a2;
      } else
        return k(Ce(s, de(i2)));
    });
  }
  function cn(e2) {
    let t2 = sr();
    if (!t2)
      return;
    let o = z();
    if (e2 = O(e2) ? e2 : t2.target, e2.length === 1 && e2[0] === "body") {
      G(o.body, A()), ae(t2, de(o));
      return;
    }
    let r = e2.join(","), s = A().querySelectorAll(r);
    ee(o.body.querySelectorAll(r), (i2, a2) => {
      G(i2, s[a2]);
    }), ae(t2, de(o));
  }
  function fn(e2) {
    return __async(this, null, function* () {
      let t2 = I(e2, 1);
      if (q(t2.key)) {
        p(3, `Cache already exists for ${t2.key}, prefetch skipped`);
        return;
      }
      let o = yield $(C(t2));
      if (o)
        return o;
      p(5, `Prefetch failed for ${t2.key}`);
    });
  }
  function ln(e2, t2) {
    return __async(this, null, function* () {
      let o = new FormData();
      for (let s in t2.data)
        o.append(s, t2.data[s]);
      return yield De(e2, { method: t2.method, body: o });
    });
  }
  function pn(e2, t2) {
    return __async(this, null, function* () {
      let o = I(e2, 7);
      if ($(o), O(t2)) {
        o.hydrate = [], o.preserve = [];
        for (let s of t2)
          s.charCodeAt(0) === 33 ? o.preserve.push(s.slice(1)) : o.hydrate.push(s);
      } else
        o.hydrate = n.config.fragments;
      let r = yield We(o);
      if (r) {
        let { key: s } = g.state;
        if (xe(r), k(r), o.key !== s) {
          n.index === s && (n.index = o.key);
          for (let i2 in n.pages)
            n.pages[i2].rev === s && (n.pages[i2].rev = o.key);
          Z(s);
        }
      }
      return z(r.key);
    });
  }
  function mn(e2, t2) {
    return __async(this, null, function* () {
      let o = I(e2), r = typeof t2 == "object" ? R(o, t2) : o;
      return q(o.key) ? Jt(o.key, ae(r)) : Jt(o.key, C(r));
    });
  }
  var Tc = Zt;

  // ../dist/index.js
  var { isArray: M2, from: C2 } = Array;
  var m2 = /* @__PURE__ */ new Map();
  var g2 = (t2, e2 = /* @__PURE__ */ Object.create(null)) => t2 ? Object.assign(e2, t2) : e2;
  var H2 = class extends Array {
    constructor() {
      super(...arguments);
      this.ref = g2();
      this.get = (s) => {
        let i2 = typeof s;
        if (i2 === "number")
          return this[s];
        if (i2 === "string") {
          if (s in this.ref)
            return this[this.ref[s]];
          console.error(`Relapse: Unknown fold id: ${s}`);
        }
        return this;
      };
    }
  };
  var w2 = (t2, e2 = 1) => {
    t2.ariaDisabled = e2 === 1 ? "true" : "false";
  };
  var c = (t2, e2, s) => t2.style.setProperty(e2, s);
  var L2 = (t2, e2) => t2.classList.add(e2);
  var R2 = (t2, e2) => t2.classList.remove(e2);
  var A2 = (t2, e2 = 1) => {
    t2.ariaExpanded = e2 === 1 ? "true" : "false";
  };
  function $2(t2, e2) {
    let s = t2, i2 = s.getAttribute(e2.schema);
    if ((i2 === null || i2 === "") && (i2 = s.hasAttribute("id") ? s.id : `R${m2.size}`, s.setAttribute(e2.schema, i2)), m2.has(i2)) {
      if (m2.get(i2).options.unique === false)
        return;
      throw new Error(`Relapse: Instance already exists with id: ${i2} `);
    }
    let o = D2(e2, s.attributes), f2 = new H2(), r = m2.set(i2, { id: i2, semantic: s.firstElementChild.nodeName === "DETAILS", openCount: 0, status: 1, active: NaN, events: g2(), get folds() {
      return f2;
    }, get options() {
      return o;
    }, get element() {
      return s;
    }, set element(n2) {
      s = n2, i2 = s.getAttribute(e2.schema);
    } }).get(i2);
    s.ariaMultiSelectable = `${r.options.multiple}`;
    let u2 = O2(r.events), b = s.children.length, E2 = r.semantic ? 1 : 2, p2 = r.options.classes, x = 0;
    do {
      let n2 = g2({ index: r.folds.length, locked: false }), l2 = false, a2, d, h;
      if (r.semantic) {
        if (h = s.children[x], h.nodeName !== "DETAILS")
          throw new Error(`Relapse: Invalid markup on "${r.id}", expected: <details>`);
        a2 = h.firstElementChild, d = a2.nextElementSibling, l2 = h.hasAttribute("open");
      } else
        a2 = s.children[x], d = h = s.children[x + 1], d.hasAttribute("hidden") ? d.removeAttribute("hidden") : d.firstElementChild.hasAttribute("hidden") && d.firstElementChild.removeAttribute("hidden");
      h.setAttribute("role", "region");
      let y = a2.classList.contains(p2.disabled), T2 = a2.classList.contains(p2.opened), F2 = d.classList.contains(p2.expanded);
      a2.ariaExpanded === "true" || l2 || T2 ? (a2.ariaExpanded !== "true" && A2(a2), !T2 && !y && L2(a2, p2.opened), F2 || L2(d, p2.expanded), (y || a2.ariaDisabled === "true") && (L2(a2, p2.disabled), w2(a2), n2.disabled = true, n2.locked = true), n2.expanded = true) : a2.ariaDisabled === "true" || y ? (a2.ariaDisabled !== "true" && w2(a2), y || L2(a2, p2.disabled), T2 && R2(a2, p2.opened), n2.expanded = (F2 || l2) === true, n2.disabled = true, n2.locked = true, A2(a2, n2.expanded ? 1 : 2)) : (n2.expanded = false, n2.disabled = false, A2(a2, 2), w2(a2, 2)), n2.id = `${r.id}-fold-${n2.index}`, a2.hasAttribute("id") || (a2.id = `${r.id}-button-${n2.index}`), d.hasAttribute("id") || (d.id = `${r.id}-content-${n2.index}`), a2.tabIndex = n2.index, a2.setAttribute("aria-controls", d.id), d.setAttribute("aria-labelledby", a2.id), n2.expanded ? (r.openCount = r.openCount + 1, r.options.multiple === false && r.openCount === 2 && console.warn(`Relapse: More than 1 fold is expanded but "multiple" is set to false on: ${r.id}`), r.semantic ? (n2.height = a2.offsetHeight + d.offsetHeight, c(h, "height", "auto")) : (n2.height = d.scrollHeight, c(h, "max-height", "inherit"))) : r.semantic ? (n2.height = a2.offsetHeight, c(h, "height", "auto")) : (n2.height = 0, c(d, "max-height", "0"), c(d, "overflow", "hidden")), n2.button = a2, n2.wrapper = h, n2.element = d, S(n2, r, u2), x = x + E2;
    } while (x < b);
    r.on = u2.on, r.off = u2.off, r.collapse = (n2 = r.active) => {
      isNaN(n2) || f2.get(n2).close(n2);
    }, r.expand = (n2 = r.active) => {
      isNaN(n2) || f2.get(n2).open(n2);
    }, r.destroy = () => {
      f2.forEach((n2) => n2.destroy()), u2.emit("destroy", r), m2.delete(i2);
    }, r.reinit = () => {
      f2.forEach((n2) => n2.destroy()), $2(t2, e2);
    };
  }
  function O2(t2) {
    let e2 = g2();
    return e2.on = (s, i2, o) => (t2[s] || (t2[s] = []), t2[s].push(o ? i2.bind(o) : i2) - 1), e2.off = (s, i2) => {
      let o = t2[s], f2 = `Relapse: Removed ${s} event listener`;
      if (o && typeof i2 == "number")
        o.splice(i2, 1), console.warn(`${f2} (id: ${i2})`), o.length === 0 && delete o[s];
      else {
        let r = [];
        if (o && typeof i2 == "function")
          for (let u2 = 0, b = o.length; u2 < b; u2++)
            o[u2] !== i2 ? r.push(o[u2]) : console.warn(`${f2} (id: ${u2})`);
        r.length > 0 ? o[s] = r : delete o[s];
      }
    }, e2.emit = (s, i2, o) => {
      let f2 = t2[s] || [], r = null;
      for (let u2 = 0, b = f2.length; u2 < b; u2++) {
        let E2 = f2[u2].call(i2, o);
        r === null && E2 === false && (r = true);
      }
      return r;
    }, e2;
  }
  function S(t2, e2, s) {
    let i2 = e2.options.classes, o = e2.options.fade, f2 = g2({ easing: o.easing, duration: o.duration * 2 }), r = (n2) => {
      if (typeof n2 != "number")
        return e2.active !== t2.index && (e2.active = t2.index), t2;
      if (e2.folds.get(n2))
        return e2.active = t2.index, e2.folds.get(n2);
      throw new Error(`Relapse: No fold exists using id: "${n2}"`);
    }, u2 = () => e2.folds.filter(({ expanded: n2 }) => n2).length, b = (n2, l2, a2) => {
      c(n2, "will-change", "opacity,visibility");
      let d = n2.animate({ opacity: l2, visibility: a2 }, l2[0] === "1" ? f2 : o);
      d.onfinish = () => {
        c(n2, "opacity", l2[1]), c(n2, "visibility", a2[1]), n2.style.removeProperty("will-change");
      };
    }, E2 = (n2, l2, a2) => {
      e2.status = 2;
      let d = n2.animate(e2.semantic ? { height: l2 } : { maxHeight: l2 }, e2.options.fold);
      d.onfinish = a2;
    }, p2 = (n2) => {
      if (n2.disabled)
        return;
      let l2 = n2.button, a2 = n2.wrapper, d = n2.element;
      c(a2, "overflow", "hidden"), e2.semantic ? (n2.height = l2.offsetHeight, c(a2, "will-change", "height")) : (n2.height = 0, c(a2, "will-change", "max-height"));
      let h = `${n2.height}px`;
      b(d, ["1", "0"], ["visible", "hidden"]), E2(a2, [`${a2.offsetHeight}px`, h], () => {
        e2.semantic ? (c(a2, "height", h), a2.removeAttribute("open")) : c(d, "max-height", "0"), n2.expanded = false, w2(l2, 2), A2(l2, 2), R2(l2, i2.opened), R2(a2, i2.expanded), a2.style.removeProperty("will-change"), e2.openCount = u2(), e2.status = 1, s.emit("collapse", e2, n2);
      });
    }, x = (n2) => (l2) => {
      n2.close();
      let a2 = n2.button, d = n2.wrapper, h = n2.element;
      w2(a2), A2(a2);
      let y;
      e2.semantic ? (d.setAttribute("open", ""), c(d, "will-change", "height"), c(d, "overflow", "hidden"), n2.height = a2.offsetHeight + h.offsetHeight, y = `${a2.offsetHeight}px`) : (c(d, "will-change", "max-height"), n2.height = h.scrollHeight, y = "0px"), L2(a2, i2.opened), b(h, ["0", "1"], ["hidden", "visible"]), E2(d, [y, `${n2.height}px`], () => {
        e2.semantic ? c(d, "height", "auto") : c(d, "max-height", "inherit"), d.style.removeProperty("overflow"), d.style.removeProperty("will-change"), L2(h, i2.expanded), n2.expanded = true, e2.openCount = u2(), e2.status = 1, e2.options.persist && e2.openCount > 1 && n2.disable(), s.emit("expand", e2, n2);
      });
    };
    t2.close = (n2) => {
      let l2 = r(n2);
      if (e2.options.multiple)
        (e2.options.persist === true && e2.openCount > 1 || e2.options.persist === false && l2.expanded === true) && p2(l2);
      else
        for (let a2 of e2.folds)
          if (a2.expanded === true && a2.locked === false) {
            if (e2.options.persist && a2.index === l2.index)
              break;
            p2(a2), l2 = a2;
            break;
          }
      l2.enable(), e2.openCount = u2();
    }, t2.focus = () => {
      e2.active = t2.index, t2.button.focus({ preventScroll: true }), s.emit("focus", e2, t2);
    }, t2.enable = (n2) => {
      let l2 = r(n2);
      l2.disabled && l2.locked === false && (l2.disabled = false, w2(l2.button, 2), R2(l2.button, i2.disabled));
    }, t2.disable = (n2) => {
      let l2 = r(n2);
      l2.disabled || (l2.expanded ? e2.options.persist && (l2.disabled = true, w2(l2.button)) : (l2.close(), l2.disabled = true, w2(l2.button), L2(l2.button, i2.disabled)));
    }, t2.open = (n2) => {
      let l2 = r(n2);
      e2.status === 2 || l2.expanded || requestAnimationFrame(x(l2));
    }, t2.toggle = (n2) => {
      if (e2.semantic && n2.preventDefault(), !(e2.status === 2 || s.emit("toggle", e2, t2) === false))
        return t2.expanded ? t2.close() : t2.open();
    }, t2.destroy = () => {
      t2.button.removeEventListener("click", t2.toggle), t2.button.removeEventListener("focus", t2.focus), t2.button.removeEventListener("blur", t2.blur);
    }, t2.button.addEventListener("click", t2.toggle), t2.button.addEventListener("focus", t2.focus), e2.folds.push(t2), e2.folds.ref[t2.element.id] = e2.folds.length - 1;
  }
  function k2(t2) {
    return typeof t2 == "object" && "schema" in t2 ? t2.schema : "[data-relapse]";
  }
  function N(t2) {
    let e2 = g2({ persist: false, unique: false, multiple: false, schema: "data-relapse", fold: g2({ duration: 200, easing: "ease-in-out" }), fade: g2({ duration: 120, easing: "linear" }), classes: g2({ opened: "opened", disabled: "disabled", expanded: "expanded" }) });
    if (typeof t2 == "object") {
      for (let s in t2)
        if (s === "classes" || s === "fade" || s === "fold")
          for (let i2 in t2[s])
            e2[s][i2] = t2[s][i2];
        else
          e2[s] = t2[s];
      "fade" in t2 && "duration" in t2.fade && t2.fade.duration !== e2.fade.duration || e2.fold.duration !== 200 && (e2.fade.duration = e2.fold.duration - e2.fold.duration / 2.5);
    }
    return e2;
  }
  function D2(t2, e2) {
    let s = t2.schema.length + 1, i2 = g2({ fold: g2(), fade: g2(), classes: g2() });
    for (let { nodeName: o, nodeValue: f2 } of e2) {
      if (!o.startsWith(t2.schema))
        continue;
      let r = o.slice(s);
      if (r === "schema") {
        console.warn('Relapse: The "schema" option cannot be defined via attribute');
        continue;
      }
      let u2 = f2.trim(), b = `Invalid ${o} attribute value.`;
      if (r === "persist" || r === "multiple" || r === "unique")
        if (u2 === "true" || u2 === "false")
          i2[r] = u2 === "true";
        else
          throw new TypeError(`Relapse: ${b}. Boolean expected, received: ${u2}`);
      else if (r === "fold-duration" || r === "fade-duration") {
        if (isNaN(+u2))
          throw new TypeError(`Relapse: ${b}. Number expected, received: ${u2}`);
        {
          let [E2, p2] = r.split("-");
          i2[E2][p2] = +u2;
        }
      } else if (r.startsWith("class-") || r === "fold-easing" || r === "fade-easing") {
        let [E2, p2] = r.split("-");
        i2[E2][p2] = u2;
      }
    }
    !("fade" in i2 && "duration" in i2.fade && i2.fade.duration !== t2.fade.duration) && "fold" in i2 && "duration" in i2.fold && i2.fold.duration !== t2.fold.duration && (i2.fade.duration = i2.fold.duration - i2.fold.duration / 2.5);
    for (let o in i2)
      if (o === "fold" || o === "classes" || o === "fade")
        for (let f2 in i2[o])
          t2[o][f2] = i2[o][f2];
      else
        t2[o] = i2[o];
    return t2;
  }
  var v2 = function t(e2, s) {
    if (document.readyState === "loading") {
      addEventListener("DOMContentLoaded", () => t(e2, s));
      return;
    }
    let i2 = typeof e2 == "object" && "tagName" in e2;
    if (i2 && e2 instanceof NodeList)
      throw TypeError("Relapse: Invalid NodeList selector. Provide string or HTMLElement");
    if (i2) {
      let f2 = typeof e2 == "string" ? document.body.querySelector(e2) : e2;
      f2 !== null && $2(f2, N(s));
    } else
      document.body.querySelectorAll(k2(e2)).forEach((f2) => $2(f2, N(e2)));
    let o = C2(m2.values());
    return i2 ? o[o.length - 1] : o;
  };
  v2.version = "0.8.0";
  v2.each = (t2) => {
    for (let [e2, s] of m2)
      if (t2(s, e2) === false)
        break;
  };
  v2.reinit = (t2) => {
    let e2 = v2.get(t2), s = M2(e2) ? e2 : [e2];
    for (let i2 of s) {
      let { id: o, options: f2 } = i2;
      i2.destroy(), v2(`#${o}`, f2);
    }
  };
  v2.has = (t2) => M2(t2) ? t2 : [t2].every(m2.has);
  v2.get = (t2) => typeof t2 == "string" ? m2.has(t2) ? m2.get(t2) : null : M2(t2) ? t2.filter((e2) => m2.has(e2)).map((e2) => m2.get(e2)) : C2(m2.values());
  window.relapse || Object.defineProperty(window, "relapse", { get() {
    return v2;
  } });
  var I2 = v2;

  // node_modules/.pnpm/qvp@0.3.2/node_modules/qvp/index.js
  var i = function(t2) {
    if (Array.isArray(t2))
      return t2.forEach(i);
    if (!("id" in t2)) {
      for (let s of ["onenter", "onexit", "oninit", "onresize"])
        if (s in t2)
          throw new Error('qvp: Missing an "id" reference');
      return Object.entries(t2).forEach(([s, o]) => {
        let c2 = typeof t2[s];
        if (c2 === "string")
          return i({ id: s, query: o });
        throw new TypeError(`qvp: Invalid query type. Expected "string" received "${c2}"`);
      });
    }
    let n2 = g3(t2), { id: r } = n2.screen;
    i.viewports.size || addEventListener("resize", u(() => {
      i.viewports.forEach((s) => {
        s.screen.active && s.onresize(window.innerWidth);
      });
    }, 25), true), i.viewports.has(r) ? console.warn(`qvp: The id "${r}" is already defined, use qvp.add() instead.`) : i.viewports.set(r, n2);
  };
  i.viewports = /* @__PURE__ */ new Map();
  Object.defineProperty(i, "isTouch", { get() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  } });
  i.get = (e2) => i.viewports.has(e2) ? i.viewports.get(e2) : false;
  i.add = (e2, t2) => {
    let n2 = i.get(e2);
    if (n2 === false)
      return console.error(`qvp: There is no viewport using an id of "${e2}"`);
    f(t2, n2.screen), n2.screen.test.matches && n2.onenter();
  };
  i.off = (e2, t2) => {
    let n2 = i.get(e2.split(":")[0]);
    if (n2 === false || !(e2 in n2.events))
      return;
    let r = n2.events[e2].length;
    if (typeof t2 == "number")
      t2 <= r - 1 && n2.events[e2].splice(t2, 1);
    else if (typeof t2 == "function") {
      let s = [];
      for (let o = 0; o < r; o++)
        n2.events[e2][o] !== t2 && s.push(n2.events[e2][o]);
      s.length > 0 && (n2.events[e2] = s);
    } else
      delete n2.events[e2];
  };
  i.on = (e2, t2, n2) => {
    let [r, s] = e2.split(":"), o = i.get(r);
    if (o === false)
      return;
    e2 in o.events || (o.events[e2] = []);
    let c2 = n2 ? t2.bind(n2) : t2;
    return c2["qvp:event"] = o.events[e2].length, o.events[e2].push(c2), o.screen.test.matches ? s === "oninit" ? c2.call() : (s === "onenter" && c2.call(), f({ [s]: c2 }, o.screen)) : f({ [s]: c2 }, o.screen), c2["qvp:event"];
  };
  i.list = (e2) => {
    let t2 = Array.from(i.viewports.values()).map(({ screen: n2 }) => n2);
    return e2 ? t2.filter(({ id: n2 }) => e2.includes(n2)) : t2;
  };
  i.active = (e2) => {
    let t2 = i.list();
    if (e2) {
      let r = i.get(e2);
      return r ? r.screen.active : false;
    }
    let n2 = t2.filter(({ active: r }) => r === true);
    return n2.length > 1 ? n2 : n2[0];
  };
  i.test = (e2, t2 = ",") => typeof e2 == "string" ? e2.indexOf(t2) > -1 ? e2.split(t2).some(i.active) : !!i.active(e2) : e2.some(i.active);
  i.remove = (e2) => {
    i.viewports.has(e2) && (i.viewports.get(e2).destroy(), i.viewports.delete(e2));
  };
  i.destroy = () => {
    removeEventListener("resize", u()), i.viewports.forEach((e2) => e2.destroy()), i.viewports.clear();
  };
  i.screens = () => {
    throw Error("qvp: The qvp.screens() is deprecated, use the default import, e.g: qvp(...)");
  };
  function u(e2, t2) {
    let n2 = t2;
    return function() {
      let r = () => {
        n2 = null, e2.apply(this, arguments);
      };
      n2 && cancelAnimationFrame(n2), n2 = requestAnimationFrame(r);
    };
  }
  function f(e2, t2) {
    typeof e2.onenter == "function" && ("qvp:event" in e2.onenter || (e2.onenter["qvp:event"] = NaN), t2.onenter.add(e2.onenter)), typeof e2.onexit == "function" && ("qvp:event" in e2.onexit || (e2.onexit["qvp:event"] = NaN), t2.onexit.add(e2.onexit)), typeof e2.onresize == "function" && ("qvp:event" in e2.onresize || (e2.onresize["qvp:event"] = NaN), t2.onresize.add(e2.onresize)), typeof e2.oninit == "function" && ("qvp:event" in e2.oninit || (e2.oninit["qvp:event"] = NaN), t2.oninit.add(e2.oninit));
  }
  function a(e2, ...t2) {
    let n2 = i.get(e2.split(":")[0]);
    if (n2 !== false && e2 in n2.events)
      for (let r = 0; r < n2.events[e2].length && (n2.events[e2][r].apply(null, t2), e2.endsWith(":oninit") && i.off(e2, r), e2 in n2.events); r++)
        ;
  }
  function g3(e2) {
    let t2 = e2.query || "all", n2 = { id: e2.id, query: t2, active: false, test: matchMedia(t2), onenter: /* @__PURE__ */ new Set(), onexit: /* @__PURE__ */ new Set(), onresize: /* @__PURE__ */ new Set(), oninit: /* @__PURE__ */ new Set(), events: /* @__PURE__ */ Object.create(null) };
    f(e2, n2);
    let r = () => {
      n2.oninit.size > 0 && (n2.oninit.forEach((v3) => !isNaN(v3["qvp:event"]) || v3()), a(`${e2.id}:oninit`), n2.oninit.clear()), n2.onenter.forEach((v3) => !isNaN(v3["qvp:event"]) || v3()), a(`${e2.id}:onenter`), n2.active = true;
    }, s = () => {
      n2.onexit.forEach((v3) => !isNaN(v3["qvp:event"]) || v3()), a(`${e2.id}:onexit`), n2.active = false;
    }, o = (v3) => {
      n2.onresize.forEach((d) => !isNaN(d["qvp:event"]) || d()), a(`${e2.id}:onresize`, v3);
    }, c2 = ({ matches: v3 }) => v3 ? r() : s(), p2 = () => {
      for (let v3 in n2.events)
        delete n2.events[v3];
      n2.test.removeEventListener("change", c2);
    };
    return n2.test.addEventListener("change", c2), n2.test.matches && r(), { onenter: r, onexit: s, onresize: o, destroy: p2, get screen() {
      return n2;
    }, get events() {
      return n2.events;
    } };
  }
  var l = i;

  // src/app/components/drawer.ts
  var _Drawer = class _Drawer extends Tc.Component {
    constructor() {
      super(...arguments);
      this.transition = (event) => {
        if (event.propertyName !== "transform")
          return;
        if (this.state.hasShift) {
          for (const shift of this.shifts) {
            if (shift.classList.contains(this.shiftClass)) {
              shift.classList.remove(this.shiftClass);
              shift.style.removeProperty("transform");
            }
          }
        }
        if (this.backdrop.classList.contains("backdrop")) {
          this.backdrop.classList.remove("backdrop");
        }
        if (this.state.mode === "pull") {
          this.shifts.item(0).removeEventListener(event.type, this.transition);
        } else {
          this.target.removeEventListener(event.type, this.transition);
        }
      };
      /**
       * Click detected outside, eg: document body
       */
      this.outsideClick = (event) => {
        if (event.target !== this.target) {
          this.close();
          this.html.removeEventListener("click", this.outsideClick, false);
        }
      };
      /**
       * Toggle Drawer
       */
      this.toggle = (event) => {
        if (event)
          event.preventDefault();
        this.state.isOpen = !this.state.isOpen;
        if (this.state.isOpen) {
          this.open();
        } else {
          this.close();
        }
        return this.state.isOpen ? this.open() : this.close();
      };
      /**
       * Touch Move prevention event
       */
      this.touchMove = (event) => {
        if (this.state.isOpen) {
          if (this.target.scrollHeight <= this.target.clientHeight) {
            event.preventDefault();
          }
        }
      };
      /**
       * Keyboard events
       */
      this.keyboard = (event) => {
        switch (event.code) {
          case "Esc":
          case "Escape":
            this.close();
            break;
        }
      };
    }
    /**
     * Returns the backdrop element
     */
    get backdrop() {
      return _Drawer.backdrop;
    }
    /**
     * Returns the drawer direction class name
     */
    get directionClass() {
      return `drawer-${this.state.direction}`;
    }
    /**
     * Returns the drawer shift class name
     */
    get shiftClass() {
      return `drawer-${this.state.mode}`;
    }
    /**
     * Returns the shifts transition class name
     */
    get shifts() {
      return this.html.querySelectorAll(this.state.shift);
    }
    /**
     * Returns all button toggles in the dom
     */
    get buttons() {
      return this.html.querySelectorAll(`[data-drawer="${this.target.id}"]`);
    }
    /**
     * Stimulus: Initialize
     */
    oninit() {
      if (!_Drawer.backdrop) {
        _Drawer.backdrop = document.createElement("div");
        _Drawer.backdrop.className = "drawer-backdrop";
        _Drawer.backdrop.setAttribute("spx-morph", "false");
      }
      if (this.state.useParent) {
        this.target = this.dom.parentElement;
        this.target.ariaHidden = "true";
      } else {
        this.target = this.dom;
      }
      if (this.target.classList.contains("d-none")) {
        this.target.classList.remove("d-none");
      }
      if (this.state.mode !== "overlay" && this.state.hasShift === false) {
        console.error('Missing "data-drawer-shift-value" defintions on:', this.target);
      }
      if (this.html.contains(_Drawer.backdrop) === false) {
        this.html.appendChild(_Drawer.backdrop);
      }
      if (this.state.hasWidth) ;
      if (this.state.hasHeight) {
        this.target.style.setProperty("height", this.state.height);
      }
      if (this.state.hasDirection && this.target.classList.contains("backdrop") === false) {
        this.target.classList.add("backdrop");
      }
      if (this.state.mode === "pull") {
        this.target.style.setProperty("transform", "translateX(0)");
        this.target.style.setProperty("z-index", "0");
      }
      if (this.html.classList.contains("drawer-open")) {
        this.html.classList.remove("drawer-open");
      }
    }
    onload() {
      if (this.state.isOpen) {
        if (l.test(["lg", "xl", "xxl"])) {
          this.close();
        } else {
          setTimeout(() => this.close(), 250);
        }
      }
    }
    /**
     * Open Drawer
     */
    open() {
      if (!this.target.classList.contains("drawer-active")) {
        this.target.classList.add("drawer-active");
      }
      if (!this.backdrop.classList.contains("backdrop")) {
        this.backdrop.classList.add("backdrop");
      }
      if (this.state.bodyScroll === false) {
        this.html.style.setProperty("overflow", "hidden");
      }
      if (this.state.hasShift) {
        this.shiftElements();
      }
      if (this.state.width) {
        if (this.state.direction === "top") {
          this.backdrop.style.setProperty("transform", `translateY(-${this.state.offset})`);
        } else {
          this.backdrop.style.setProperty("transform", `translateX(${this.state.width})`);
        }
      }
      this.html.classList.add("drawer-open");
      this.backdrop.addEventListener("click", this.toggle, { once: true });
      this.target.addEventListener("touchstart", this.touchStart, { passive: true });
      this.target.ariaHidden = "false";
    }
    close() {
      if (this.state.isOpen) {
        this.state.isOpen = false;
      }
      if (this.state.width) {
        this.backdrop.style.removeProperty("transform");
      }
      if (this.state.bodyScroll === false) {
        this.html.style.removeProperty("overflow");
      }
      if (this.state.hasShift) {
        this.shiftElements();
      } else {
        this.target.addEventListener("transitionend", this.transition);
      }
      this.html.classList.remove("drawer-open");
      this.target.removeEventListener("touchstart", this.touchStart);
      this.backdrop.removeEventListener("click", this.toggle);
      this.target.classList.remove("drawer-active");
      this.target.ariaHidden = "true";
    }
    /**
     * Set attribute requirements for the elements which apply transform shifting
     */
    shiftElements() {
      if (this.state.mode === "pull") {
        this.target.style.setProperty("transform", "translateX(0)");
        this.target.style.setProperty("z-index", "0");
        if (this.state.isOpen === false) {
          this.shifts.item(0).addEventListener("transitionend", this.transition);
        }
      } else {
        if (this.state.isOpen === false) {
          this.target.addEventListener("transitionend", this.transition);
        }
      }
      for (const shift of this.shifts) {
        if (this.state.isOpen) {
          if (!shift.classList.contains(this.shiftClass)) {
            shift.classList.add(this.shiftClass);
          }
          if (this.state.width && (this.state.direction === "left" || this.state.direction === "right")) {
            shift.style.setProperty("transform", `translateX(${this.state.width})`);
          } else if (this.state.hasHeight && (this.state.direction === "top" || this.state.direction === "bottom")) {
            shift.style.setProperty("transform", `translateY(${this.state.height})`);
          }
        } else {
          if (this.state.width && (this.state.direction === "left" || this.state.direction === "right")) {
            shift.style.setProperty("transform", "translateX(0)");
          } else if (this.state.hasHeight && (this.state.direction === "top" || this.state.direction === "bottom")) {
            shift.style.setProperty("transform", "translateY(0)");
          }
        }
      }
    }
    /**
     * Touch Start scroll position
     */
    touchStart({ target }) {
      if (target instanceof HTMLElement) {
        const { scrollTop, offsetHeight } = target;
        const position = scrollTop + offsetHeight;
        if (scrollTop === 0) {
          target.scrollTop = 1;
        } else if (position === scrollTop) {
          target.scrollTop = scrollTop - 1;
        }
      }
    }
  };
  /**
   * Stimulus: values
   */
  _Drawer.connect = {
    state: {
      outsideClick: Boolean,
      height: String,
      width: String,
      offset: String,
      direction: String,
      shift: String,
      redraw: String,
      useParent: {
        typeof: Boolean,
        default: false
      },
      isOpen: {
        typeof: Boolean,
        default: false
      },
      bodyScroll: {
        typeof: Boolean,
        default: false
      },
      backdrop: {
        typeof: Boolean,
        default: true
      },
      mode: {
        typeof: String,
        default: "overlay"
      }
    }
  };
  var Drawer = _Drawer;

  // src/app/components/tabs.ts
  var Tabs = class extends Tc.Component {
    toggle({ target }) {
      this.state.open = +target.getAttribute("data-index");
      for (const btn of this.btnNodes) {
        btn.classList.remove("active");
      }
      for (const tab of this.tabNodes) {
        tab.classList.remove("d-block");
        tab.classList.add("d-none");
      }
      this.btnNodes[this.state.open].classList.add("active");
      this.tabNodes[this.state.open].classList.remove("d-none");
      this.tabNodes[this.state.open].classList.add("d-block");
    }
  };
  Tabs.connect = {
    state: {
      open: {
        default: 0,
        typeof: Number
      }
    }
  };

  // src/app/components/methods.ts
  var Methods = class extends Tc.Component {
    onload() {
      this.methods = I2(this.relapseNode, {
        multiple: true,
        persist: false
      });
      this.methods.on("toggle", (fold) => {
        if (fold.expanded) {
          this.collapse({ attrs: { fold: fold.index } });
        } else {
          this.expand({ attrs: { fold: fold.index } });
        }
      });
    }
    expand({ attrs }) {
      this.methods.expand(attrs.fold);
      this.openerNodes[attrs.fold].classList.add("disabled");
      this.openerNodes[attrs.fold].classList.remove("active");
      this.closerNodes[attrs.fold].classList.remove("disabled");
      this.closerNodes[attrs.fold].classList.add("active");
    }
    collapse({ attrs }) {
      this.methods.collapse(attrs.fold);
      this.openerNodes[attrs.fold].classList.remove("disabled");
      this.closerNodes[attrs.fold].classList.remove("active");
      this.closerNodes[attrs.fold].classList.add("disabled");
    }
    disable({ attrs }) {
      this.methods.expand(attrs.fold);
    }
  };
  Methods.connect = {
    state: {
      open: {
        default: 0,
        typeof: Number
      }
    }
  };

  // src/app/components/events.ts
  var Events = class extends Tc.Component {
    constructor() {
      super(...arguments);
      this.colors = ["fc-cyan", "fc-pink", "fc-purple", "fc-green"];
    }
    onload() {
      this.relapse = I2(this.relapseNode);
      this.relapse.on("focus", this.focus, this);
      this.relapse.on("collapse", this.collapse, this);
      this.relapse.on("expand", this.expand, this);
      this.relapse.on("toggle", this.toggle, this);
    }
    insert(message, fold) {
      ++this.state.count;
      const element = document.createElement("div");
      element.className = `d-block pb-1 message ${this.colors[fold]}`;
      element.ariaLabel = `${this.state.count}`;
      element.innerText = message;
      this.logNode.appendChild(element);
      this.logNode.scrollTop = this.logNode.scrollHeight;
    }
    toggle(fold) {
      this.insert(
        `Fold at index ${fold.index} was toggled and will ${fold.expanded ? "collapse" : "expand"}`,
        fold.index
      );
    }
    focus(fold) {
      this.insert(
        `Fold at index ${fold.index} was focused and will ${fold.expanded ? "collapse" : "expand"}`,
        fold.index
      );
    }
    collapse(fold) {
      this.insert(
        `Fold at index ${fold.index} was collapsed and is closed`,
        fold.index
      );
    }
    expand(fold) {
      this.insert(
        `Fold at index ${fold.index} was expanded and is open`,
        fold.index
      );
    }
  };
  Events.connect = {
    state: {
      count: Number
    }
  };

  // src/app/components/dropdown.ts
  var Dropdown = class extends Tc.Component {
    /**
     * Returns all `<label>` elements in the dropdown
     */
    inViewport() {
      const rect = this.collapseNode.getBoundingClientRect();
      for (const { element, folds } of I2.get()) {
        if (element.id === this.state.accordion) {
          if (!(rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth))) {
            folds.find((fold) => fold.expanded === true).close();
          }
          break;
        }
      }
    }
    /**
     * Toggle - Open/Close
     */
    toggle(event) {
      event.stopPropagation();
      if (this.dom.classList.contains("is-open"))
        return this.close();
      this.state.collapse = "opened";
      this.dom.classList.add("is-open");
      this.buttonNode.classList.remove("selected");
      if (this.state.hasAccordion)
        this.inViewport();
      addEventListener("click", this.outsideClick.bind(this));
    }
    /**
     * Click detected outside, eg: document body
     */
    outsideClick(event) {
      if (this.buttonNode !== event.target && this.collapseNode !== event.target) {
        if (this.dom.classList.contains("is-open")) {
          this.close();
        }
      }
    }
    /**
     * Close Dropdown
     */
    close() {
      this.dom.classList.remove("is-open");
      if (this.state.collapse === "selected" || this.state.hasSelected) {
        this.dom.classList.add("selected");
        this.state.collapse = "selected";
      } else {
        this.state.collapse = "closed";
      }
      removeEventListener("click", this.outsideClick);
      this.buttonNode.focus();
    }
    /**
     * Select Inputs
     *
     * Used for Dropdown Forms
     */
    select({ target }) {
      target.checked = true;
      this.state.selected = target.value;
      this.buttonNode.innerText = target.getAttribute("aria-label");
      this.state.collapse = "selected";
      for (const label of this.dom.getElementsByTagName("label")) {
        if (label.getAttribute("for") === target.id) {
          if (!label.classList.contains("selected")) {
            label.classList.add("selected");
          }
        } else {
          if (label.classList.contains("selected")) {
            label.classList.remove("selected");
          }
        }
      }
      this.close();
    }
    /**
     * Items in dropdown - An ul > li <select> element equivelent
     */
    option(event) {
      if (event.target instanceof HTMLElement) {
        if (event.currentTarget instanceof HTMLElement) {
          const [selected] = event.currentTarget.getElementsByClassName("selected");
          if (selected)
            this.state.selected = selected.id;
        }
        if (event.currentTarget instanceof HTMLElement) ;
        if (this.state.hasRequired) {
          if (this.buttonNode.classList.contains("is-invalid")) {
            this.buttonNode.classList.remove("is-invalid");
          }
          this.state.required = false;
          this.buttonNode.classList.add("selected");
        }
        if (this.state.kind === "preset") {
          this.state.selected = `Preset (${event.target.textContent.trim()})`;
          this.buttonNode.innerHTML = `Preset (${event.target.textContent.trim()})<span class="icon"></span>`;
        } else {
          this.state.selected = event.target.textContent;
          this.buttonNode.textContent = event.target.textContent;
        }
        for (const node of this.collapseNode.children) {
          if (node.id !== event.target.id) {
            node.classList.remove("selected");
          } else {
            node.classList.add("selected");
          }
        }
        this.state.collapse = "selected";
        this.toggle(event);
      }
    }
  };
  Dropdown.connect = {
    state: {
      selected: String,
      form: String,
      accordion: String,
      kind: String,
      required: {
        typeof: Boolean,
        default: false
      },
      collapse: {
        typeof: String,
        default: "closed"
      },
      type: {
        typeof: String,
        default: "dropdown"
      }
    }
  };

  // src/app/bundle.ts
  Tc.connect(
    {
      fragments: [
        "main",
        "menu"
      ],
      components: {
        Methods,
        Dropdown,
        Events,
        Tabs,
        Drawer
      }
    }
  )(function() {
    I2();
  });
  Tc.on("load", function({ key }) {
    I2.reinit();
  });

})();
