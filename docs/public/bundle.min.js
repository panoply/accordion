(function () {
  'use strict';

  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../../brixtol/packages/spx/index.js
  var ur = Object.defineProperty;
  var mt = (e, t) => {
    for (var r in t)
      ur(e, r, { get: t[r], enumerable: true });
  };
  var y = (e, t, r) => new Promise((n, s) => {
    var i2 = (p) => {
      try {
        a2(r.next(p));
      } catch (g2) {
        s(g2);
      }
    }, c = (p) => {
      try {
        a2(r.throw(p));
      } catch (g2) {
        s(g2);
      }
    }, a2 = (p) => p.done ? n(p.value) : Promise.resolve(p.value).then(i2, c);
    a2((r = r.apply(e, t)).next());
  });
  var O = typeof window != "undefined" ? window : { screen: {}, navigator: {} };
  var te = (O.matchMedia || function() {
    return { matches: false };
  }).bind(O);
  var pr = { get passive() {
    return true;
  } };
  var dt = function() {
  };
  O.addEventListener && O.addEventListener("p", dt, pr);
  O.removeEventListener && O.removeEventListener("p", dt, false);
  var Ce = "ontouchstart" in O;
  var dr = "TouchEvent" in O;
  var ke = Ce || dr && te("(any-pointer: coarse)").matches;
  var pt = (O.navigator.maxTouchPoints || 0) > 0 || ke;
  var ht = O.navigator.userAgent || "";
  var hr = te("(pointer: coarse)").matches && /iPad|Macintosh/.test(ht) && Math.min(O.screen.width || 0, O.screen.height || 0) >= 768;
  var gr = (te("(pointer: coarse)").matches || !te("(pointer: fine)").matches && Ce) && !/Windows.*Firefox/.test(ht);
  var yr = te("(any-pointer: fine)").matches || te("(any-hover: hover)").matches || hr || !Ce;
  var ie = pt && (yr || !gr) ? "hybrid" : pt ? "touchOnly" : "mouseOnly";
  "content" in document.createElement("template");
  document.createRange && "createContextualFragment" in document.createRange();
  var I = ke ? "pointer" : "mouse";
  var d = window.history;
  var _ = window.location.origin;
  var R = Object.assign;
  var x = Object.create;
  var X = Array.isArray;
  var Ae = Array.from;
  var j = "";
  var h = class extends XMLHttpRequest {
    constructor() {
      super(...arguments);
      this.key = null;
    }
  };
  h.request = /* @__PURE__ */ new Map(), h.transit = /* @__PURE__ */ new Map(), h.timeout = /* @__PURE__ */ new Map();
  var o = new class {
    constructor() {
      this.loaded = false;
      this.selectors = x(null);
      this.config = { targets: ["body"], timeout: 3e4, globalThis: true, schema: "spx", render: "replace", manual: false, logs: true, cache: true, limit: 100, preload: null, async: true, annotate: false, eval: { script: null, style: null, link: null, meta: false }, hover: { trigger: "href", threshold: 250 }, intersect: { rootMargin: "0px 0px 0px 0px", threshold: 0 }, proximity: { distance: 75, threshold: 250, throttle: 500 }, progress: { background: "#111", height: "3px", minimum: 0.08, easing: "linear", speed: 200, trickle: true, threshold: 500, trickleSpeed: 200 } };
      this.events = x(null);
      this.observers = x(null);
      this.memory = x(null);
      this.pages = x(null);
      this.snapshots = x(null);
      this.tracked = /* @__PURE__ */ new Set();
      this.resources = /* @__PURE__ */ new Map();
      this.stylesheets = /* @__PURE__ */ new Set();
    }
  }();
  function gt(e, t) {
    try {
      return JSON.parse(t.replace(/\\'|'/g, (r) => r[0] === "\\" ? r : '"').replace(/([{,])\s*(.+?)\s*:/g, '$1 "$2":'));
    } catch (r) {
      return l(4, `Invalid JSON expression in attribute value: ${e}`, r), t;
    }
  }
  function yt() {
    return new Promise((e) => setTimeout(() => e(), 0));
  }
  function vt(e) {
    setTimeout(() => e(), 1);
  }
  function xt(e) {
    let t = document.createElement("textarea");
    return t.innerHTML = e, t.value;
  }
  function l(e, t, r) {
    if (e === 1 && o.config.logs === true)
      console.info("SPX: " + t);
    else if (e === 2 && o.config.logs === true)
      console.warn("SPX: " + t);
    else {
      r ? console.error("SPX: " + t, r) : console.error("SPX: " + t);
      try {
        throw e === 3 ? new TypeError(t) : new Error(t);
      } catch (n) {
      }
    }
  }
  function Ie(e) {
    return (t) => typeof t == "string" ? t in e : t.every((r) => r in e);
  }
  function E(e, t) {
    return t in e;
  }
  function Et() {
    return Math.random().toString(36).slice(2);
  }
  function bt(e = 2) {
    return (t, r) => {
      let n = t.length;
      return (n < 1 || t[n - 1].length === e ? t.push([r]) : t[n - 1].push(r)) && t;
    };
  }
  function He(e) {
    return e < 1024 ? e + " B" : e < 1048576 ? (e / 1024).toFixed(1) + " KB" : e < 1073741824 ? (e / 1048576).toFixed(1) + " MB" : (e / 1073741824).toFixed(1) + " GB";
  }
  function D(e, t) {
    if (arguments.length === 1)
      return (n) => D(e, n);
    let r = t.length;
    if (r !== 0)
      for (let n = 0; n < r; n++)
        e(t[n], n, t);
  }
  function qe(e) {
    for (let t in e)
      delete e[t];
  }
  function Er(e) {
    return E(e, "hover") && (e.hover === false ? o.config.hover = false : typeof e.hover == "object" && R(o.config.hover, e.hover), delete e.hover), E(e, "intersect") && (e.intersect === false ? o.config.intersect = false : typeof e.intersect == "object" && R(o.config.intersect, e.intersect), delete e.intersect), E(e, "proximity") && (e.proximity === false ? o.config.proximity = false : typeof e.proximity == "object" && R(o.config.proximity, e.proximity), delete e.proximity), E(e, "progress") && (e.progress === false ? o.config.progress = null : typeof e.progress == "object" && R(o.config.progress, e.progress), delete e.progress), e;
  }
  function De(e = {}) {
    R(o.config, Er(e)), E(e, "eval") && R(o.config.eval, e.eval), o.config.index = null;
    let t = o.config.schema === "spx" ? "spx" : o.config.schema.endsWith("-") ? o.config.schema.slice(0, -1) : o.config.schema, r = `:not([${t}-disable]):not([href^="#"])`;
    o.selectors.morph = `${t}-morph`, o.selectors.render = `${t}-render`, o.selectors.hrefs = o.config.annotate ? `a[${t}-link]${r}` : `a${r}`, o.selectors.tracking = `[${t}-track]:not([${t}-track=false])`, o.selectors.scripts = n("script"), o.selectors.scriptsHydrate = `script[${t}-eval=hydrate]:not([${t}-eval=false])`, o.selectors.styles = n("style"), o.selectors.links = n("link"), o.selectors.metas = n("meta"), o.selectors.evals = `[${t}-eval]:not([${t}-eval=false]):not(script)`, o.selectors.attributes = new RegExp("^href|" + t + "-(hydrate|append|prepend|target|progress|threshold|position|proximity|hover|data|cache)$", "i"), o.selectors.proximity = `a[${t}-proximity]${r}${s("proximity")}`, o.selectors.intersector = `[${t}-intersect]${s("intersect")}`, o.selectors.intersects = `a${r}${s("intersect")}`, o.selectors.hover = o.config.hover.trigger === "href" ? `a${r}${s("hover")}` : `a[${t}-hover]${r}${s("hover")}`, o.memory.bytes = 0, o.memory.visits = 0, o.memory.limit = o.config.limit;
    function n(i2) {
      let c = `not([${t}-eval=false])`, a2 = i2 === "link" ? `${i2}[rel=stylesheet]:${c},${i2}[rel~=preload]:${c}` : i2 === "script" ? `${i2}[${t}-eval]:${c}:not([${t}-eval=hydrate])` : `${i2}:${c}`;
      if (o.config.eval[i2] === false || o.config.eval[i2] === null)
        return a2;
      if (o.config.eval[i2] === true)
        return `${i2}[${t}-eval]:${c}`;
      if (X(o.config.eval[i2]))
        return o.config.eval[i2].length > 0 ? o.config.eval[i2].map((p) => `${p}:${c}`).join(",") : (l(2, `Missing eval ${i2} option, SPX will use defaults`), a2);
      l(3, `Invalid eval ${i2} option, expected boolean or array`);
    }
    function s(i2) {
      let c = `:not([${t}-${i2}=false]):not([${t}-link])`;
      switch (i2.charCodeAt(0)) {
        case 104:
          return `${c}:not([${t}-proximity]):not([${t}-intersect])`;
        case 105:
          return `${c}:not([${t}-hover]):not([${t}-proximity])`;
        case 112:
          return `${c}:not([${t}-intersect]):not([${t}-hover])`;
      }
    }
  }
  var Tt = /(?:https?:)?(?:\/\/(?:www\.)?|(?:www\.))/;
  var Pt = /\b(?:append|prepend)/;
  var Rt = /^(?:application|text)\/(?:x-)?(?:ecma|java)script|text\/javascript$/;
  var We = /^\b(?:true|false)$/i;
  var ce = /^[+-]?\d*\.?\d+$/;
  var At = /\s+/g;
  var It = /\b(?:intersect|hover|proximity)\b/;
  var Fe = /\[?[^,'"[\]()\s]+\]?/g;
  var wt = /\[(['"]?.*['"]?,?)\]/;
  var Xe = /[xy]\s*|\d*\.?\d+/gi;
  var L = _.replace(Tt, j);
  function Ve(e, t) {
    let r = t || x(null);
    for (let { nodeName: n, nodeValue: s } of e.attributes)
      if (n.startsWith(`${o.config.schema}-data:`)) {
        E(r, "data") || (r.data = x(null));
        let i2 = n.slice(n.lastIndexOf(":") + 1), c = s.trim();
        ce.test(c) ? r.data[i2] = Number(c) : We.test(c) ? r.data[i2] = c === "true" : c[0] === "{" || c[0] === "[" ? r.data[i2] = gt(n, c) : r.data[i2] = c;
      } else {
        if (!o.selectors.attributes.test(n))
          continue;
        if (n === "href")
          r.rev = location.pathname + location.search, t || (r.location = Ye(s), r.key = r.location.pathname + r.location.search);
        else {
          let i2 = n.slice(n.lastIndexOf("-") + 1), c = s.replace(At, j).trim();
          if (wt.test(c))
            r[i2] = Pt.test(i2) ? c.match(Fe).reduce(bt(2), []) : c.match(Fe);
          else if (i2 === "position" && Xe.test(c)) {
            let a2 = c.match(Xe);
            r[`scroll${a2[0].toUpperCase()}`] = +a2[1], a2.length === 4 && (r[`scroll${a2[2].toUpperCase()}`] = +a2[3]);
          } else
            We.test(c) ? It.test(n) || (r[i2] = c === "true") : ce.test(c) ? r[i2] = +c : r[i2] = c;
        }
      }
    return r;
  }
  function re(e) {
    let t = x(null);
    if (e.length === 1 && e.charCodeAt(0) === 47)
      return t.pathname = e, t.hash = j, t.search = j, t;
    let n = e.indexOf("#");
    n >= 0 ? (t.hash = e.slice(n), e = e.slice(0, n)) : t.hash = j;
    let s = e.indexOf("?");
    return s >= 0 ? (t.search = e.slice(s), e = e.slice(0, s)) : t.search = j, t.pathname = e, t;
  }
  function we(e, t) {
    let r = e.indexOf("/", t);
    if (r > t) {
      let s = e.indexOf("#", r);
      return s < 0 ? e.slice(r) : e.slice(r, s);
    }
    let n = e.indexOf("?", t);
    if (n > t) {
      let s = e.indexOf("#", n);
      return s < 0 ? e.slice(n) : e.slice(n, s);
    }
    return e.length - t === L.length ? "/" : null;
  }
  function je(e) {
    let t = e.startsWith("www.") ? e.slice(4) : e, r = t.indexOf("/");
    if (r >= 0) {
      let n = t.slice(r);
      if (t.slice(0, r) === L)
        return n.length > 0 ? re(n) : re("/");
    } else {
      let n = t.search(/[?#]/);
      if (n >= 0) {
        if (t.slice(0, n) === L)
          return re("/" + t.slice(n));
      } else if (t === L)
        return re("/");
    }
    return null;
  }
  function Tr(e) {
    return e.startsWith("http") ? 1 : e.startsWith("//") ? 2 : e.startsWith("www.") ? 3 : 0;
  }
  function Nt(e) {
    if (typeof e != "string" || e.length === 0)
      return false;
    if (e.charCodeAt(0) === 47)
      return e.charCodeAt(1) !== 47 ? true : e.startsWith("www.", 2) ? e.startsWith(L, 6) : e.startsWith(L, 2);
    if (e.charCodeAt(0) === 63)
      return true;
    if (e.startsWith("www."))
      return e.startsWith(L, 4);
    if (e.startsWith("http")) {
      let t = e.indexOf("/", 4) + 2;
      return e.startsWith("www.", t) ? e.startsWith(L, t + 4) : e.startsWith(L, t);
    }
  }
  function Pr(e) {
    return e.charCodeAt(0) === 47 ? e.charCodeAt(1) !== 47 ? re(e) : je(e.slice(2)) : e.charCodeAt(0) === 63 ? re(location.pathname + e) : e.startsWith("https:") || e.startsWith("http:") ? je(e.slice(e.indexOf("/", 4) + 2)) : e.startsWith("www.") ? je(e) : null;
  }
  function $(e) {
    if (typeof e == "object")
      return e.pathname + e.search;
    if (e === j)
      return "/";
    let t = Tr(e);
    if (t === 1) {
      let r = e.charCodeAt(4) === 115 ? 8 : 7, n = e.startsWith("www.", r) ? r + 4 : r;
      return e.startsWith(L, n) ? we(e, n) : null;
    }
    if (t === 2) {
      let r = e.startsWith("www.", 2) ? 6 : 2;
      return e.startsWith(L, r) ? we(e, r) : null;
    }
    return t === 3 ? e.startsWith(L, 4) ? we(e, 4) : null : e.startsWith(L, 0) ? we(e, 0) : null;
  }
  function Lt() {
    return { hostname: L, origin: _, pathname: location.pathname, search: location.search, hash: location.hash };
  }
  function Ye(e) {
    if (e === j)
      return Lt();
    let t = Pr(e);
    return t === null && l(4, `Invalid pathname: ${e}`), t.origin = _, t.hostname = L, t;
  }
  function b(e, t = 6) {
    if (e instanceof Element) {
      let n = Ve(e);
      return n.type = t || 6, n;
    }
    let r = x(null);
    return e === 0 ? (r.location = Lt(), r.key = $(r.location), r.rev = r.key, r.type = e) : t === 7 ? (r.location = Ye(e), r.key = $(r.location), r.rev = r.key, r.type = t) : (r.rev = location.pathname + location.search, r.location = Ye(typeof e == "string" ? e : r.rev), r.key = $(r.location), r.type = t), r;
  }
  function oe(e) {
    return new DOMParser().parseFromString(e, "text/html");
  }
  function Ke(e) {
    let t = e.indexOf(">", e.indexOf("<title")) + 1, r = e.indexOf("</title", t);
    return xt(e.slice(t, r).trim());
  }
  function w(e, ...t) {
    let r = e === "cache";
    r && (t[1] = oe(t[1]));
    let n = true;
    return D((s) => {
      let i2 = s.apply(null, t);
      r ? i2 instanceof Document ? n = i2.documentElement.outerHTML : typeof n != "string" && (n = i2 !== false) : n = i2 !== false;
    }, o.events[e] || []), n;
  }
  function Ot(e, t, r) {
    E(o.events, e) || (o.events[e] = []), o.events[e].push(r ? t.bind(r) : t);
  }
  function $t(e, t) {
    let r = o.events[e], n = [];
    if (r && t) {
      let s = 0, i2 = r.length;
      for (; s < i2; s++)
        r[s] !== t && n.push(r[s]);
    }
    return n.length ? o.events[e] = n : delete o.events[e], this;
  }
  function Y(e) {
    e ? typeof e == "string" ? (delete o.snapshots[o.pages[e].uuid], delete o.pages[e]) : X(e) && D((t) => {
      delete o.snapshots[o.pages[t].uuid], delete o.pages[t];
    }, e) : (qe(o.pages), qe(o.snapshots));
  }
  function T(e) {
    let t = Ie(e);
    return e.target = t("target") ? e.target.length === 1 && e.target[0] === "body" ? e.target : [].concat(o.config.targets, e.target) : o.config.targets, o.config.cache && (t("cache") || (e.cache = o.config.cache), t("uuid") || (e.uuid = Et())), t("scrollY") || (e.scrollY = 0), t("scrollX") || (e.scrollX = 0), o.config.hover !== false && e.type === 10 && (t("threshold") || (e.threshold = o.config.hover.threshold)), o.config.proximity !== false && e.type === 12 && (t("proximity") || (e.proximity = o.config.proximity.distance), t("threshold") || (e.threshold = o.config.proximity.threshold)), o.config.progress && !t("progress") && (e.progress = o.config.progress.threshold), t("render") || (e.render = o.config.render), t("visits") || (e.visits = 0), o.pages[e.key] = e, o.pages[e.key];
  }
  function ne(e, t) {
    let r = w("cache", e, t), n = typeof r == "string" ? r : t;
    return e.type > 5 && e.type > 9 && (e.type = 1), e.title = Ke(t), !o.config.cache || r === false ? e : E(e, "uuid") ? (o.pages[e.key] = e, o.snapshots[e.uuid] = n, e) : S(e, n);
  }
  function S(e, t) {
    let r = E(o.pages, e.key) ? o.pages[e.key] : T(e);
    return typeof t == "string" && (o.snapshots[r.uuid] = t, e.title = Ke(t)), R(r, e);
  }
  function Mt() {
    let e = d.state.key;
    if (E(o.pages, e))
      return o.pages[e];
    l(4, `No record exists: ${e}`);
  }
  function ae(e) {
    if (!e) {
      if (d.state === null)
        return;
      e = d.state.key;
    }
    if (E(o.pages, e)) {
      let t = x(null);
      return t.page = o.pages[e], t.dom = oe(o.snapshots[t.page.uuid]), t;
    }
    l(4, `No record exists: ${e}`);
  }
  function N(e) {
    return E(o.pages, e) && E(o.pages[e], "uuid") && E(o.snapshots, o.pages[e].uuid) && typeof o.snapshots[o.pages[e].uuid] == "string";
  }
  function le(e, t) {
    if (!(e instanceof Element))
      return false;
    let r = e.closest(t);
    return r && r.tagName === "A" ? r : false;
  }
  function Be(e) {
    if (e.nodeName !== "A")
      return false;
    let t = e.href;
    return Nt(t) ? !N($(t)) : false;
  }
  function St(e, t) {
    let r = [];
    return document.body.querySelectorAll(e).forEach((n) => {
      n.nodeName !== "A" ? n.querySelectorAll(t).forEach((s) => {
        Be(n) && r.push(s);
      }) : Be(n) && r.push(n);
    }), r;
  }
  var fe = (e) => {
    let t = [];
    return document.body.querySelectorAll(e).forEach((r) => {
      Be(r) && t.push(r);
    }), t;
  };
  function ue(e, { method: t = "GET", body: r = null, headers: n = null, type: s = "text" } = {}) {
    return new Promise(function(i2, c) {
      let a2 = new h();
      if (a2.key = e, a2.responseType = s, a2.open(t, e), a2.setRequestHeader("spx-request", "true"), n !== null)
        for (let p in n)
          a2.setRequestHeader(p, n[p]);
      a2.addEventListener("loadstart", function() {
        h.request.set(this.key, a2);
      }), a2.addEventListener("load", function() {
        i2(this.response);
      }), a2.addEventListener("error", function() {
        c(this.statusText);
      }), a2.addEventListener("abort", function() {
        h.timeout.delete(this.key), h.transit.delete(this.key), h.request.delete(this.key);
      }), a2.addEventListener("loadend", function(p) {
        h.request.delete(this.key), o.memory.bytes = o.memory.bytes + p.loaded, o.memory.visits = o.memory.visits + 1;
      }), a2.send(r);
    });
  }
  function Ne(e) {
    return h.timeout.has(e) ? (clearTimeout(h.timeout.get(e)), h.timeout.delete(e)) : true;
  }
  function Le(e, t, r) {
    h.timeout.has(e) || N(e) || h.timeout.set(e, setTimeout(t, r));
  }
  function Ue(e) {
    for (let [t, r] of h.request)
      e !== t && (r.abort(), l(2, `Pending request aborted: ${t}`));
  }
  function Ct(e) {
    if (o.config.preload !== null) {
      if (X(o.config.preload)) {
        let t = o.config.preload.filter((r) => {
          let n = b(r, 3);
          return n.key !== r ? P(T(n)) : false;
        });
        return Promise.allSettled(t);
      } else if (typeof o.config.preload == "object" && E(o.config.preload, e.key)) {
        let t = o.config.preload[e.key].map(function(r) {
          return P(T(b(r, 3)));
        });
        return Promise.allSettled(t);
      }
    }
  }
  function Oe(e) {
    return y(this, null, function* () {
      let t = T(b(e, 4));
      yield yt(), P(t).then((r) => {
        r ? l(1, `Reverse fetch completed: ${r.key}`) : l(2, `Reverse fetch failed: ${e}`);
      });
    });
  }
  function me(e) {
    return y(this, null, function* () {
      if (!h.transit.has(e.key))
        return e;
      let t = yield h.transit.get(e.key);
      return h.transit.delete(e.key), h.timeout.delete(e.key), ne(e, t);
    });
  }
  function P(e) {
    return y(this, null, function* () {
      return h.request.has(e.key) && e.type !== 7 ? (e.type === 4 && h.request.has(e.rev) ? (h.request.get(e.rev).abort(), l(2, `Request aborted: ${e.rev}`)) : l(2, `Request in transit: ${e.key}`), false) : w("fetch", e) ? (h.transit.set(e.key, ue(e.key)), me(e)) : (l(2, `Request cancelled via dispatched event: ${e.key}`), false);
    });
  }
  function kt(e) {
    let t = le(e.target, o.selectors.hover);
    if (!t)
      return;
    let r = b(t, 10);
    if (N(r.key) || h.timeout.has(r.key))
      return;
    t.addEventListener(`${I}leave`, Ht, { once: true });
    let n = T(r), s = n.threshold || o.config.hover.threshold;
    Le(r.key, function() {
      w("prefetch", t, r) && P(n).then(function(i2) {
        h.timeout.delete(r.key), qt(t);
      });
    }, s);
  }
  function Ht(e) {
    let t = le(e.target, o.selectors.hover);
    t && Ne($(t.href));
  }
  function Rr(e) {
    e.addEventListener(`${I}enter`, kt);
  }
  function qt(e) {
    e.removeEventListener(`${I}enter`, kt), e.removeEventListener(`${I}leave`, Ht);
  }
  function pe() {
    !o.config.hover || o.observers.hover || (D(Rr, fe(o.selectors.hover)), o.observers.hover = true);
  }
  function G() {
    o.observers.hover && (D(qt, fe(o.selectors.hover)), o.observers.hover = false);
  }
  function Ar({ clientX: e, clientY: t }, r) {
    return e <= r.right && e >= r.left && t <= r.bottom && t >= r.top;
  }
  function Ir(e) {
    let t = e.getBoundingClientRect(), r = e.getAttribute(o.selectors.proximity), n = ce.test(r) ? Number(r) : o.config.proximity.distance;
    return { target: e, top: t.top - n, bottom: t.bottom + n, left: t.left - n, right: t.right + n };
  }
  function wr(e) {
    let t = false;
    return function(r) {
      if (t)
        return;
      t = true;
      let n = e.findIndex((s) => Ar(r, s));
      if (n === -1)
        setTimeout(() => {
          t = false;
        }, o.config.proximity.throttle);
      else {
        let { target: s } = e[n], i2 = T(b(s, 12)), c = i2.threshold || o.config.proximity.threshold;
        Le(i2.key, () => y(this, null, function* () {
          if (!w("prefetch", s, i2))
            return K();
          (yield P(i2)) && (e.splice(n, 1), t = false, e.length === 0 && (K(), l(1, "Proximity observer disconnected")));
        }), c);
      }
    };
  }
  var ze;
  function de() {
    if (!o.config.proximity || o.observers.proximity)
      return;
    let e = fe(o.selectors.proximity).map(Ir);
    e.length > 0 && (ze = wr(e), addEventListener(`${I}move`, ze, { passive: true }), o.observers.proximity = true);
  }
  function K() {
    o.observers.proximity && (removeEventListener(`${I}move`, ze), o.observers.proximity = false);
  }
  var J;
  function Nr(e) {
    return y(this, null, function* () {
      if (e.isIntersecting) {
        let t = b(e.target, 11);
        if (!w("prefetch", e.target, t))
          return J.unobserve(e.target);
        (yield P(T(t))) ? J.unobserve(e.target) : (l(2, `Prefetch will retry at next intersect for: ${t.key}`), J.observe(e.target));
      }
    });
  }
  function he() {
    if (!o.config.intersect || o.observers.intersect)
      return;
    J || (J = new IntersectionObserver(D(Nr), o.config.intersect));
    let e = D((r) => J.observe(r)), t = St(o.selectors.intersector, o.selectors.intersects);
    e(t), o.observers.intersect = true;
  }
  function Z() {
    o.observers.intersect && (J.disconnect(), o.observers.intersect = false);
  }
  var se = null;
  var Dt;
  var ge = null;
  var Ze = [];
  function Qe(e) {
    e = Ft(e, o.config.progress.minimum, 1), se = e === 1 ? null : e;
    let t = Lr();
    $r((r) => {
      if (t.style.setProperty("transform", `translateX(${Xt(e)}%)`), e !== 1)
        return setTimeout(r, o.config.progress.speed);
      setTimeout(() => {
        Or(), r();
      }, o.config.progress.speed * 2);
    });
  }
  function Wt(e) {
    let t = se;
    if (!t)
      return $e();
    if (t < 1)
      return typeof e != "number" && (t >= 0 && t < 0.2 ? e = 0.1 : t >= 0.2 && t < 0.5 ? e = 0.04 : t >= 0.5 && t < 0.8 ? e = 0.02 : t >= 0.8 && t < 0.99 ? e = 5e-3 : e = 0), t = Ft(t + e, 0, 0.994), Qe(t);
  }
  function Lr() {
    if (ge)
      return ge;
    document.documentElement.classList.add("spx-load");
    let e = Xt(se || 0), t = document.createElement("div");
    return t.id = "spx-progress", t.style.cssText = `opacity:1;pointer-events:none;background-color:${o.config.progress.background};height:${o.config.progress.height};position:fixed;z-index:9999999;top:0;left:0;width:100%;will-change:transform;transition:opacity 100ms ease-out,transform ${o.config.progress.speed}ms ${o.config.progress.easing};transform:translateX(${e}%);`, document.body.appendChild(t), ge = t, t;
  }
  function Or() {
    document.documentElement.classList.remove("spx-load"), document.getElementById("spx-progress") && document.body.removeChild(ge), ge = null;
  }
  function Ft(e, t, r) {
    return e < t ? t : e > r ? r : e;
  }
  function Xt(e) {
    return (-1 + e) * 100;
  }
  function $r(e) {
    let t = () => {
      let r = Ze.shift();
      r && r(t);
    };
    Ze.push(e), Ze.length === 1 && t();
  }
  function $e(e) {
    o.config.progress && (Dt = setTimeout(() => {
      se || Qe(0);
      function t() {
        setTimeout(() => {
          se && (Wt(), t());
        }, o.config.progress.trickleSpeed);
      }
      o.config.progress.trickle && t();
    }, e || 0));
  }
  function jt(e) {
    if (clearTimeout(Dt), !(!e && !se))
      return Wt(0.8 * Math.random()), Qe(1);
  }
  function Mr() {
    window.scrollY >= 0 && (o.position.scrollY = window.scrollY), window.scrollX >= 0 && (o.position.scrollX = window.scrollX), console.log(o.position);
  }
  function Vt() {
    o.observers.scroll && (removeEventListener("scroll", Mr, false), o.observers.scroll = false);
  }
  function Cr(e) {
    return new Promise((t, r) => {
      let n = document.createElement("script");
      n.addEventListener("error", r, { once: true }), n.async = false, n.text = e.target.text;
      for (let { nodeName: s, nodeValue: i2 } of e.target.attributes)
        n.setAttribute(s, i2);
      document.contains(e.target) ? e.target.replaceWith(n) : (document.head.append(n), e.external ? n.addEventListener("load", () => n.remove(), { once: true }) : n.remove()), e.external && n.addEventListener("load", () => t(), { once: true }), t();
    });
  }
  function kr(e) {
    if (!e.hasAttribute("src") && !e.text)
      return;
    let t = e.type ? e.type.trim().toLowerCase() : "text/javascript", r = Rt.test(t) ? 1 : t === "module" ? 2 : NaN, n = x(null);
    return n.blocking = true, n.evaluate = false, n.external = false, isNaN(r) || e.noModule && r === 1 || (e.src && (n.external = true), (r !== 1 || n.external && (e.hasAttribute("async") || e.defer)) && (n.blocking = false), n.evaluate = true, n.target = e), n;
  }
  function Kt(e) {
    return y(this, null, function* () {
      try {
        let t = Cr(e);
        e.blocking && (yield t);
      } catch (t) {
        console.error(t);
      }
    });
  }
  function Bt(e) {
    return y(this, null, function* () {
      let r = Ae(e, kr).filter((n) => n.evaluate).reduce((n, s) => y(this, null, function* () {
        return s.external ? Promise.all([n, Kt(s)]) : (yield n, yield Kt(s));
      }), Promise.resolve());
      yield Promise.race([r]);
    });
  }
  function Ut(e) {
    return e ? e.getAttribute && e.getAttribute("id") || e.id : void 0;
  }
  function ye(e, t) {
    let r = e.nodeName, n = t.nodeName;
    if (r === n)
      return true;
    let s = r.charCodeAt(0), i2 = n.charCodeAt(0);
    return s <= 90 && i2 >= 97 || s <= 90 && i2 >= 97 ? r === n.toUpperCase() : false;
  }
  function _t(e, t) {
    return !t || t === "http://www.w3.org/1999/xhtml" ? document.createElement(e) : document.createElementNS(t, e);
  }
  function zt(e, t) {
    let r = e.firstChild;
    for (; r; ) {
      let n = r.nextSibling;
      t.appendChild(r), r = n;
    }
    return t;
  }
  function Gt(e, t) {
    if (t.nodeType === 11 || e.nodeType === 11)
      return;
    let r = t.attributes, n, s, i2, c, a2;
    for (let g2 = r.length - 1; g2 >= 0; g2--)
      n = r[g2], s = n.name, c = n.value, i2 = n.namespaceURI, i2 ? (s = n.localName || s, a2 = e.getAttributeNS(i2, s), a2 !== c && (n.prefix === "xmlns" && (s = n.name), e.setAttributeNS(i2, s, c))) : (a2 = e.getAttribute(s), a2 !== c && e.setAttribute(s, c));
    let p = e.attributes;
    for (let g2 = p.length - 1; g2 >= 0; g2--)
      n = p[g2], s = n.name, c = n.value, i2 = n.namespaceURI, i2 ? (s = n.localName || s, t.hasAttributeNS(i2, s) || e.removeAttributeNS(i2, s)) : t.hasAttribute(s) || e.removeAttribute(s);
  }
  var rt = {};
  mt(rt, { INPUT: () => Dr, OPTION: () => qr, SELECT: () => Wr, TEXTAREA: () => tt });
  function et(e, t, r) {
    e[r] !== t[r] && (e[r] = t[r], e[r] ? e.setAttribute(r, "") : e.removeAttribute(r));
  }
  function qr(e, t) {
    let r = e.parentNode;
    if (r) {
      let n = r.nodeName.toUpperCase();
      n === "OPTGROUP" && (r = r.parentNode, n = r && r.nodeName.toUpperCase()), n === "SELECT" && !r.hasAttribute("multiple") && (e.hasAttribute("selected") && !t.selected && (e.setAttribute("selected", "selected"), e.removeAttribute("selected")), r.selectedIndex = -1);
    }
    et(e, t, "selected");
  }
  function Dr(e, t) {
    et(e, t, "checked"), et(e, t, "disabled"), e.value !== t.value && (e.value = t.value), t.hasAttribute("value") || e.removeAttribute("value");
  }
  function tt(e, t) {
    let r = t.value;
    e.value !== r && (e.value = r);
    let n = e.firstChild;
    if (n) {
      let s = n.nodeValue;
      if (s === r || !r && s === e.placeholder)
        return;
      n.nodeValue = r;
    }
  }
  function Wr(e, t) {
    if (!t.hasAttribute("multiple")) {
      let r = -1, n = 0, s = e.firstElementChild, i2, c;
      for (; s; )
        if (c = s.nodeName && s.nodeName.toUpperCase(), c === "OPTGROUP")
          i2 = s, s = i2.firstElementChild;
        else {
          if (c === "OPTION") {
            if (s.hasAttribute("selected")) {
              r = n;
              break;
            }
            n++;
          }
          s = s.nextElementSibling, !s && i2 && (s = i2.nextElementSibling, i2 = null);
        }
      e.selectedIndex = r;
    }
  }
  function Me() {
  }
  function Q(e, t, r) {
    r || (r = {}), t.nodeType === 11 && (t = t.firstElementChild);
    let n = r.getNodeKey || Ut, s = r.onNodeAdded || Me, i2 = r.onBeforeNodeDiscarded || Me, c = r.onNodeDiscarded || Me, a2 = r.onBeforeElChildrenUpdated || Me, p = /* @__PURE__ */ new Map(), g2 = [];
    function at(m, u2) {
      if (m.nodeType === 1) {
        let f2 = m.firstChild;
        for (; f2; ) {
          let v2;
          u2 && (v2 = n(f2)) ? g2.push(v2) : f2.firstChild && at(f2, u2), f2 = f2.nextSibling;
        }
      }
    }
    function Ee(m, u2, f2) {
      i2(m) !== false && (u2 && u2.removeChild(m), at(m, f2));
    }
    function lt(m) {
      if (m.nodeType === 1 || m.nodeType === 11) {
        let u2 = m.firstChild;
        for (; u2; ) {
          let f2 = n(u2);
          f2 && p.set(f2, u2), lt(u2), u2 = u2.nextSibling;
        }
      }
    }
    lt(e);
    function Se(m) {
      s(m);
      let u2 = m.firstChild;
      for (; u2; ) {
        let f2 = u2.nextSibling, v2 = n(u2);
        if (v2) {
          let k = p.get(v2);
          k && ye(u2, k) ? (u2.parentNode.replaceChild(k, u2), be(k, u2)) : Se(u2);
        } else
          Se(u2);
        u2 = f2;
      }
    }
    function lr(m, u2, f2) {
      for (; u2; ) {
        let v2 = u2.nextSibling;
        (f2 = n(u2)) ? g2.push(f2) : Ee(u2, m, true), u2 = v2;
      }
    }
    function be(m, u2) {
      let f2 = n(u2);
      f2 && p.delete(f2), m.isEqualNode(u2) !== true && m.getAttribute(o.selectors.morph) !== "false" && (m.getAttribute(o.selectors.morph) !== "children" && Gt(m, u2), a2(m, u2) !== false && (m.nodeName !== "TEXTAREA" ? fr(m, u2) : tt(m, u2)));
    }
    function fr(m, u2) {
      let f2 = u2.firstChild, v2 = m.firstChild, k, H, ee, Pe, U;
      e:
        for (; f2; ) {
          for (Pe = f2.nextSibling, k = n(f2); v2; ) {
            if (ee = v2.nextSibling, f2.isSameNode && f2.isSameNode(v2)) {
              f2 = Pe, v2 = ee;
              continue e;
            }
            H = n(v2);
            let Re = v2.nodeType, W;
            if (Re === f2.nodeType && (Re === 1 ? (k ? k !== H && ((U = p.get(k)) ? ee === U ? W = false : (m.insertBefore(U, v2), H ? g2.push(H) : Ee(v2, m, true), v2 = U, H = n(v2)) : W = false) : H && (W = false), W = W !== false && ye(v2, f2), W === false && p.has(H) && p.get(H).getAttribute(o.selectors.morph) === "children" && (W = true), W && be(v2, f2)) : (Re === 3 || Re === 8) && (W = true, v2.nodeValue !== f2.nodeValue && (v2.nodeValue = f2.nodeValue))), W) {
              f2 = Pe, v2 = ee;
              continue e;
            }
            H ? g2.push(H) : Ee(v2, m, true), v2 = ee;
          }
          k && (U = p.get(k)) && ye(U, f2) ? (m.appendChild(U), be(U, f2)) : (f2.actualize && (f2 = f2.actualize(m.ownerDocument || document)), m.appendChild(f2), Se(f2)), f2 = Pe, v2 = ee;
        }
      lr(m, v2, H);
      let ut = rt[m.nodeName];
      ut && ut(m, u2);
    }
    let A2 = e, Te = A2.nodeType, ft = t.nodeType;
    if (Te === 1)
      ft === 1 ? ye(e, t) || (c(e), A2 = zt(e, _t(t.nodeName, t.namespaceURI))) : A2 = t;
    else if (Te === 3 || Te === 8) {
      if (ft === Te)
        return A2.nodeValue !== t.nodeValue && (A2.nodeValue = t.nodeValue), A2;
      A2 = t;
    }
    if (A2 === t)
      c(e);
    else {
      if (t.isSameNode && t.isSameNode(A2))
        return;
      if (be(A2, t), g2)
        for (let m = 0, u2 = g2.length; m < u2; m++) {
          let f2 = p.get(g2[m]);
          f2 && Ee(f2, f2.parentNode, false);
        }
    }
    return A2 !== e && e.parentNode && (A2.actualize && (A2 = A2.actualize(e.ownerDocument || document)), e.parentNode.replaceChild(A2, e)), A2;
  }
  function Fr(e, t) {
    return e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_PRECEDING || -1;
  }
  function Jt(e, t) {
    return y(this, null, function* () {
      let r = t === 7 ? o.selectors.scriptsHydrate : o.selectors.scripts, n = Ae(e.querySelectorAll(r));
      yield Bt(n.sort(Fr));
    });
  }
  function Xr(e) {
    document.head.querySelectorAll(o.selectors.evals).forEach((t) => {
      e.head.contains(t) || t.remove();
    }), document.head.append(...e.querySelectorAll(o.selectors.evals));
  }
  function jr(e) {
    let t = e.querySelectorAll(o.selectors.tracking);
    if (t !== null)
      for (let r of t)
        r.hasAttribute("id") ? o.tracked.has(r.id) || (document.body.appendChild(r), o.tracked.add(r.id)) : l(2, `Tracked node <${r.tagName.toLowerCase()}> must contain an id attribute`);
  }
  function Yr(e, t) {
    let r = e.target, n = e.render;
    if (r.length === 1 && r[0] === "body")
      n === "morph" ? Q(document.body, t.body) : n === "replace" ? document.body.replaceWith(t.body) : document.body.innerHTML = t.body.innerHTML;
    else {
      let s = r.join(","), i2 = t.body.querySelectorAll(s);
      document.body.querySelectorAll(s).forEach((c, a2) => {
        if (c.isEqualNode(i2[a2]) || !w("render", c, i2[a2]))
          return;
        let p = n;
        if (c.hasAttribute(o.selectors.render)) {
          let g2 = c.getAttribute(o.selectors.render);
          g2 !== p && (p = g2);
        }
        if (p === "morph" ? Q(c, i2[a2]) : e.render === "replace" ? c.replaceWith(i2[a2]) : c.innerHTML = i2[a2].innerHTML, e.append || e.prepend) {
          let g2 = document.createElement("div");
          return t.childNodes.forEach(g2.appendChild), e.append ? c.appendChild(g2) : c.insertBefore(g2, c.firstChild);
        }
      }), jr(t.body);
    }
  }
  function Vr(e, t) {
    let r = e.hydrate;
    if (r.length === 1 && r[0] === "body") {
      Q(document.body, t.body);
      return;
    }
    let n = r.join(","), s = document.body.querySelectorAll(n), i2 = e.preserve && e.preserve.length > 0 ? e.preserve.join(",") : null, c = [];
    if (i2 && document.body.querySelectorAll(i2).forEach((a2) => {
      a2.setAttribute("spx-morph", "false"), c.push(a2);
    }), s.length > 0) {
      let a2 = t.body.querySelectorAll(n);
      s.forEach((p, g2) => {
        if (a2[g2] instanceof HTMLElement) {
          if (!w("hydrate", p, a2[g2]))
            return;
          Q(p, a2[g2]);
        }
      });
    }
    if (i2)
      for (let a2 of c)
        a2.removeAttribute("spx-morph");
    Jt(t, 7), e.hydrate = void 0, e.preserve = void 0, e.type = 6, S(e);
  }
  function C(e) {
    return y(this, null, function* () {
      G(), Z(), K(), document.title = e.title;
      let t = oe(o.snapshots[e.uuid]);
      return e.type === 7 ? Vr(e, t) : (Xr(t), Yr(e, t), Jt(t, e.type), scrollTo(e.scrollX, e.scrollY)), jt(), vt(() => {
        pe(), he(), de();
      }), w("load", e), e;
    });
  }
  var xe = {};
  mt(xe, { api: () => d, connect: () => nt, disconnect: () => st, exists: () => Zt, initialize: () => Qt, push: () => ve, replace: () => B, reverse: () => Kr });
  function Kr() {
    return d.state !== null && E(d.state, "rev") && d.state.key !== d.state.rev;
  }
  function Zt(e) {
    if (d.state == null || typeof d.state != "object")
      return false;
    let t = Ie(d.state)(["key", "rev", "scrollX", "scrollY", "title"]);
    return typeof e == "string" ? t && d.state.key === e : t;
  }
  function Qt(e) {
    return Zt(e.key) ? (scrollTo(d.state.scrollX, d.state.scrollY), R(e, d.state)) : (B(e), e);
  }
  function B(e) {
    let t = x(null);
    return t.key = e.key, t.rev = e.rev, t.title = e.title || document.title, t.scrollX = e.scrollX, t.scrollY = e.scrollY, d.replaceState(t, t.title, t.key), l(1, `ReplaceState: ${d.state.key}`), d.state;
  }
  function ve(e) {
    let t = x(null);
    return t.key = e.key, t.rev = e.rev, t.title = e.title, t.scrollY = 0, t.scrollX = 0, d.pushState(t, t.title, t.key), l(1, `PushState: ${d.state.key}`), d.state;
  }
  function er(e) {
    return y(this, null, function* () {
      if (e.state !== null)
        if (N(e.state.key))
          N(e.state.rev) === false && e.state.rev !== e.state.key && Oe(e.state.rev), l(1, `PopState: ${e.state.key}`), o.pages[e.state.key].type = 5, yield C(o.pages[e.state.key]);
        else {
          e.state.type = 5;
          let t = yield P(e.state);
          if (!t)
            return location.assign(e.state.key);
          let r = $(location);
          if (t.key === r)
            yield C(t);
          else if (N(r))
            yield C(o.pages[r]);
          else {
            let n = T(b(r, 5));
            yield P(n), d.pushState(n, document.title, r);
          }
        }
    });
  }
  function nt(e) {
    if (!o.observers.history)
      return d.scrollRestoration && (d.scrollRestoration = "manual"), addEventListener("popstate", er, false), o.observers.history = true, typeof e == "object" && e.type === 0 ? Qt(e) : e;
  }
  function st() {
    o.observers.history && (d.scrollRestoration && (d.scrollRestoration = "auto"), removeEventListener("popstate", er, false), o.observers.history = false);
  }
  function Br(e) {
    return !(e.target && e.target.isContentEditable || e.defaultPrevented || e.which > 1 || e.altKey || e.ctrlKey || e.metaKey || e.shiftKey);
  }
  var M = function(e) {
    if (!Br(e))
      return;
    let t = le(e.target, o.selectors.hrefs);
    if (!t)
      return;
    let r = $(t.href);
    if (r === null)
      return;
    function n() {
      M.drag = true, l(2, `Drag occurance on link: ${r}`), t.removeEventListener(`${I}move`, n);
    }
    if (t.addEventListener(`${I}move`, n, { once: true }), M.drag === true)
      return M.drag = false, M(e);
    if (t.removeEventListener(`${I}move`, n), !!w("visit", e))
      if (Vt(), G(), K(), Z(), N(r)) {
        let s = Ve(t, o.pages[r]), i2 = S(s);
        t.onclick = function(c) {
          c.preventDefault(), o.pages[i2.rev].scrollX = window.scrollX, o.pages[i2.rev].scrollY = window.scrollY, B(o.pages[i2.rev]), ve(i2), C(i2);
        };
      } else if (h.transit.has(r)) {
        Ue(r), l(1, `Request in transit: ${r}`);
        let s = o.pages[r];
        t.onclick = function(i2) {
          i2.preventDefault(), o.pages[s.rev].scrollX = window.scrollX, o.pages[s.rev].scrollY = window.scrollY, B(o.pages[s.rev]), it(s);
        };
      } else {
        Ue(), Ne(r);
        let s = T(b(t, 6));
        P(s), t.onclick = function(i2) {
          i2.preventDefault(), o.pages[s.rev].scrollX = window.scrollX, o.pages[s.rev].scrollY = window.scrollY, B(o.pages[s.rev]), it(s);
        };
      }
  };
  function it(e) {
    return y(this, null, function* () {
      e.progress && $e(e.progress);
      let t = yield me(e);
      if (t)
        ve(t), C(t);
      else
        return location.assign(e.key);
    });
  }
  function ct(e, t) {
    return y(this, null, function* () {
      if (t) {
        typeof t.cache == "string" && (t.cache === "clear" ? Y() : Y(t.key)), t.progress && $e(t.progress);
        let r = yield P(t);
        r ? (ve(r), C(r)) : location.assign(t.key);
      } else
        return it(o.pages[e]);
    });
  }
  function tr() {
    o.observers.hrefs || (M.drag = false, ie === "mouseOnly" ? addEventListener(`${I}down`, M, false) : (ie === "touchOnly" || addEventListener(`${I}down`, M, false), addEventListener("touchstart", M, false)), o.observers.hrefs = true);
  }
  function rr() {
    o.observers.hrefs && (ie === "mouseOnly" ? removeEventListener(`${I}down`, M, false) : (ie === "touchOnly" || removeEventListener(`${I}down`, M, false), removeEventListener("touchstart", M, false)), o.observers.hrefs = false);
  }
  function nr() {
    let e = b(0), t = nt(T(e));
    o.index = t.key;
    function r() {
      let n = ne(t, document.documentElement.outerHTML);
      return tr(), o.config.manual === false && (pe(), he(), de()), n.rev !== n.key && setTimeout(() => Oe(n.rev), 1), setTimeout(() => Ct(n), 1), n;
    }
    return new Promise((n) => {
      if (document.readyState === "complete" || document.readyState === "interactive")
        return n(r());
      addEventListener("DOMContentLoaded", () => n(r()), { once: true });
    });
  }
  function sr() {
    G(), pe(), Z(), he(), K(), de();
  }
  function ir() {
    st(), rr(), G(), Z(), K(), Y(), o.config.globalThis && delete window.spx, l(1, "Disconnected \u{1F614}");
  }
  var cr = !!(window.history.pushState && window.requestAnimationFrame && window.addEventListener && window.DOMParser);
  var ar = R(x(null), { supported: cr, on: Ot, off: $t, observe: sr, history: xe, connect: Ur, capture: Qr, form: to, render: Zr, session: _r, state: zr, reload: Gr, fetch: Jr, clear: Y, hydrate: ro, prefetch: eo, visit: oo, disconnect: ir, get config() {
    return o.config;
  } });
  function Ur(e = {}) {
    if (typeof document == "undefined")
      return l(4, "SPX only runs in the browser");
    if (!cr)
      return l(4, "Browser does not support SPX");
    if (!window.location.protocol.startsWith("http"))
      return l(4, "Invalid protocol, SPX expects https or http protocol");
    De(e);
    let t = nr();
    return function(r) {
      return y(this, null, function* () {
        let n = yield t;
        if (o.config.globalThis && Object.defineProperty(window, "spx", { get() {
          return ar;
        } }), r.constructor.name === "AsyncFunction")
          try {
            yield r(n);
          } catch (s) {
            l(2, "Connection Error", s);
          }
        else
          r(n);
        l(1, "Connection Established \u26A1");
      });
    };
  }
  function _r(e, t) {
    if (e)
      if (t)
        e === "config" && De(t), e === "observers" && R(o.observers, t);
      else {
        if (e === "config")
          return o.config;
        if (e === "observers")
          return o.observers;
        if (e === "pages")
          return o.pages;
        if (e === "snapshots")
          return o.snapshots;
        if (e === "memory")
          return He(o.memory.bytes);
      }
    let r = x(null);
    return r.config = o.config, r.snapshots = o.snapshots, r.pages = o.pages, r.observers = o.observers, r.memory = o.memory, r.memory.size = He(r.memory.bytes), r;
  }
  function zr(e, t) {
    if (e === void 0)
      return ae();
    if (typeof e == "string") {
      let r = $(e);
      N(r) || l(4, `No store exists at: ${r}`);
      let n = ae(r);
      return t !== void 0 ? S(R(n.page, t)) : n;
    }
    if (typeof e == "object")
      return S(e);
  }
  function Gr() {
    return y(this, null, function* () {
      let e = o.pages[d.state.key];
      e.type = 9;
      let t = yield P(e);
      return t ? (l(1, "Triggered reload, page was re-cached"), C(t)) : (l(2, "Reload failed, triggering refresh (cache will be purged)"), location.assign(e.key));
    });
  }
  function Jr(e) {
    return y(this, null, function* () {
      let t = b(e, 2);
      t.location.origin !== _ && l(4, "Cross origin fetches are not allowed");
      let r = yield ue(t.key);
      if (r)
        return r;
    });
  }
  function Zr(e, t, r) {
    return y(this, null, function* () {
      let n = Mt(), s = b(e);
      s.location.origin !== _ && l(4, "Cross origin fetches are not allowed");
      let i2 = yield ue(s.key, { type: "document" });
      if (i2 || l(4, `Fetch failed for: ${s.key}`, i2), yield r.call(n, i2), t === "replace") {
        n.title = i2.title;
        let c = S(R(n, s), i2.documentElement.outerHTML);
        return B(c), c;
      } else
        return C(ne(s, i2.documentElement.outerHTML));
    });
  }
  function Qr(e) {
    let t = ae();
    if (!t)
      return;
    let { page: r, dom: n } = t;
    if (e = X(e) ? e : r.target, e.length === 1 && e[0] === "body") {
      n.body.replaceChildren(document.body), S(r, n.documentElement.innerHTML);
      return;
    }
    let s = e.join(","), i2 = document.body.querySelectorAll(s);
    n.body.querySelectorAll(s).forEach((c, a2) => {
      Q(c, i2[a2]);
    }), S(r, n.documentElement.innerHTML);
  }
  function eo(e) {
    return y(this, null, function* () {
      let t = b(e, 1);
      if (N(t.key)) {
        l(2, `Cache already exists for ${t.key}, prefetch skipped`);
        return;
      }
      let r = yield P(T(t));
      if (r)
        return r;
      l(4, `Prefetch failed for ${t.key}`);
    });
  }
  function to(e, t) {
    return y(this, null, function* () {
      let r = new FormData();
      for (let s in t.data)
        r.append(s, t.data[s]);
      return yield ue(e, { method: t.method, body: r });
    });
  }
  function ro(e, t) {
    return y(this, null, function* () {
      let r = b(e, 7);
      if (P(r), X(t)) {
        r.hydrate = [], r.preserve = [];
        for (let s of t)
          s.charCodeAt(0) === 33 ? r.preserve.push(s.slice(1)) : r.hydrate.push(s);
      } else
        r.hydrate = o.config.targets;
      let n = yield me(r);
      if (n) {
        let { key: s } = d.state;
        if (B(n), C(n), r.key !== s) {
          o.index === s && (o.index = r.key);
          for (let i2 in o.pages)
            o.pages[i2].rev === s && (o.pages[i2].rev = r.key);
          Y(s);
        }
      }
      return ae(n.key).dom;
    });
  }
  function oo(e, t) {
    return y(this, null, function* () {
      let r = b(e), n = typeof t == "object" ? R(r, t) : r;
      return N(r.key) ? ct(r.key, S(n)) : ct(r.key, T(n));
    });
  }
  var Ps = ar;

  // ../dist/index.js
  function b2(n) {
    let l3 = /* @__PURE__ */ Object.create(null);
    return n ? Object.assign(l3, n) : l3;
  }
  var w2 = class extends Array {
    constructor() {
      super(...arguments);
      this.refs = b2();
      this.get = (i2) => {
        let s = typeof i2;
        if (s === "number")
          return this[i2];
        if (s === "string") {
          if (i2 in this.refs)
            return this[this.refs[i2]];
          throw new Error(`Relapse: No fold using an id value of: ${i2}`);
        } else if (s === "undefined")
          return this;
      };
    }
  };
  function v(n) {
    return {
      on: (u2, o2) => {
        n[u2] || (n[u2] = []), n[u2].push(o2);
      },
      off: (u2, o2) => {
        let a2 = n[u2], p = [];
        if (a2 && o2)
          for (let d2 = 0, t = a2.length; d2 < t; d2++)
            a2[d2] !== o2 && p.push(a2[d2]);
        p.length > 0 ? a2[u2] = p : delete a2[u2];
      },
      emit: (u2, o2, a2) => {
        let p = n[u2] || [], d2 = null;
        for (let t = 0, r = p.length; t < r; t++) {
          let e = p[t].call(o2, a2);
          d2 === null && e === false && (d2 = true);
        }
        return d2;
      }
    };
  }
  function E2(n, l3, i2) {
    let { classes: s } = n.config, u2 = (t, r, e) => {
      let f2 = t.animate({ opacity: r, visibility: e }, {
        duration: n.config.fading.duration,
        easing: n.config.fading.easing
      });
      f2.onfinish = () => {
        t.style.setProperty("opacity", r[1]), t.style.setProperty("visibility", e[1]), f2.cancel();
      };
    }, o2 = (t, r, e) => {
      let f2 = t.wrapper.animate(n.semantic ? { height: r } : { maxHeight: r }, {
        duration: n.config.folding.duration,
        easing: n.config.folding.easing
      });
      f2.onfinish = e;
    }, a2 = (t) => {
      if (typeof t != "number")
        return n.active !== i2.index && (n.active = i2.index), i2;
      if (n.folds.get(t))
        return n.active = i2.index, n.folds.get(t);
      throw new Error(`Relapse: No fold exists at index: ${t}`);
    }, p = (t) => {
      n.semantic ? (t.height = t.button.offsetHeight, t.wrapper.style.setProperty("overflow", "hidden")) : t.height = 0, u2(t.element, ["1", "0"], ["visible", "hidden"]), o2(t, [`${t.wrapper.offsetHeight}px`, `${t.height}px`], () => {
        n.semantic ? (t.wrapper.style.setProperty("height", `${t.height}px`), t.wrapper.removeAttribute("open")) : t.element.style.setProperty("max-height", "0"), t.expanded = false, t.button.ariaDisabled = "false", t.button.ariaExpanded = "false", t.button.classList.remove(s.opened), t.wrapper.classList.remove(s.expanded);
      });
    }, d2 = (t) => (r) => {
      t.close(), t.wrapper.style.setProperty("overflow", "hidden"), t.button.ariaDisabled = "true", t.button.ariaExpanded = "true", t.button.classList.add(s.opened);
      let e;
      n.semantic ? (t.wrapper.setAttribute("open", ""), t.height = t.button.offsetHeight + t.element.offsetHeight, e = `${t.button.offsetHeight}px`) : (t.height = t.element.scrollHeight, e = "0px"), u2(t.element, ["0", "1"], ["hidden", "visible"]), o2(t, [e, `${t.height}px`], () => {
        n.semantic ? t.wrapper.style.setProperty("height", "auto") : t.element.style.setProperty("max-height", `${t.height}px`), t.wrapper.style.removeProperty("overflow"), t.wrapper.classList.add(s.expanded), t.expanded = true, n.openCount = n.folds.filter(({ expanded: f2 }) => f2).length, n.config.persist === true && n.openCount > 1 && t.disable(), l3.emit("expand", n, t);
      });
    };
    return i2.open = (t) => {
      let r = a2(t);
      r.expanded || requestAnimationFrame(d2(r));
    }, i2.close = (t) => {
      let r = a2(t);
      if (n.config.multiple)
        (n.config.persist === true && n.openCount > 1 || n.config.persist === false && r.expanded === true) && p(r);
      else
        for (let e of n.folds)
          if (e.expanded === true) {
            if (n.config.persist && e.index === r.index)
              break;
            p(e), r = e;
            break;
          }
      r.enable(), n.openCount = n.folds.filter(({ expanded: e }) => e).length, l3.emit("collapse", n, r);
    }, i2.focus = () => {
      n.active = i2.index, i2.button.classList.add(s.focused), l3.emit("focus", n, i2);
    }, i2.blur = () => {
      i2.button.classList.remove(s.focused);
    }, i2.enable = (t) => {
      let r = a2(t);
      r.disabled && (r.disabled = false, r.button.ariaDisabled = "false", r.button.classList.remove(s.disabled));
    }, i2.disable = (t) => {
      let r = a2(t);
      r.disabled || (r.expanded ? n.config.persist && (r.disabled = true, r.button.ariaDisabled = "true") : (r.close(), r.disabled = true, r.button.ariaDisabled = "true", r.button.classList.add(s.disabled)));
    }, i2.toggle = (t) => {
      if (n.semantic && t.preventDefault(), l3.emit("toggle", n, i2) !== false)
        return i2.expanded ? i2.close() : i2.open();
    }, i2.destroy = (t = false) => {
      i2.button.removeEventListener("click", i2.toggle), i2.button.removeEventListener("focus", i2.focus), i2.button.removeEventListener("blur", i2.blur), t && (n.element.removeChild(i2.element), n.element.removeChild(i2.button));
    }, i2.button.addEventListener("click", i2.toggle), i2.button.addEventListener("focus", i2.focus), i2.button.addEventListener("blur", i2.blur), i2;
  }
  function $2(n) {
    let l3 = b2({
      persist: false,
      unique: false,
      multiple: false,
      schema: "data-relapse",
      folding: b2({
        duration: 220,
        easing: "ease-in-out",
        hint: true
      }),
      fading: b2({
        duration: 120,
        easing: "linear",
        hint: true
      }),
      classes: b2({
        opened: "opened",
        disabled: "disabled",
        expanded: "expanded",
        focused: "focused"
      })
    });
    if (typeof n == "object")
      for (let i2 in n)
        if (i2 === "classes" || i2 === "fading" || i2 === "folding")
          for (let s in n[i2])
            l3[i2][s] = n[i2][s];
        else
          l3[i2] = n[i2];
    return l3;
  }
  function L2(n, l3) {
    let i2 = n.schema.length + 1;
    for (let { nodeName: s, nodeValue: u2 } of l3) {
      if (!s.startsWith(n.schema))
        continue;
      let o2 = s.slice(i2), a2 = u2.trim();
      if (o2 === "persist" || o2 === "multiple" || o2 === "unique")
        if (a2 === "true" || a2 === "false")
          n[o2] = a2 === "true";
        else
          throw new TypeError(
            `Relapse: Invalid ${s} attribute value. Boolean expected, received: ${a2}`
          );
      else if (o2.endsWith("-duration")) {
        if (isNaN(+a2))
          throw new TypeError(
            `Relapse: Invalid ${s} attribute value. Number expected, received: ${a2}`
          );
        {
          let [p, d2] = o2.split("-");
          n[p][d2] = +a2;
        }
      } else if (o2.startsWith("class-") || o2.endsWith("-easing")) {
        let [p, d2] = o2.split("-");
        n[p][d2] = a2;
      }
    }
    return b2(n);
  }
  function y2(n, l3) {
    let i2 = n.getAttribute(l3.schema);
    if ((i2 === null || i2 === "") && (n.hasAttribute("id") ? (i2 = Math.random().toString(36).slice(2), n.setAttribute(l3.schema, i2)) : i2 = n.id), window.relapse.has(i2)) {
      if (window.relapse.get(i2).config.unique)
        return;
      throw new Error(`Relapse: Identifier must be unique! An instance exists for: ${i2} `);
    }
    let s = window.relapse.set(i2, b2(
      {
        element: n,
        key: i2,
        config: L2(l3, n.attributes),
        folds: new w2(),
        id: `R${window.relapse.size}`,
        semantic: n.firstElementChild.nodeName === "DETAILS",
        openCount: 0,
        active: -1,
        events: b2()
      }
    )).get(i2);
    s.element.ariaMultiSelectable = `${s.config.multiple}`;
    let u2 = n.children, o2 = u2.length, a2 = s.semantic ? 1 : 2, p = v(s.events), { classes: d2 } = s.config, t = 0;
    do {
      let e = b2({ index: s.folds.length });
      e.id = `${s.id}F${e.index}`;
      let f2 = false;
      if (s.semantic) {
        if (e.wrapper = u2[t], e.wrapper.nodeName !== "DETAILS") {
          let c = e.wrapper;
          throw new Error(
            `Relapse: Invalid markup, expected "<details>" received <${c.nodeName}> in: ${c.innerHTML}`
          );
        }
        e.button = e.wrapper.firstElementChild, e.element = e.button.nextElementSibling, f2 = e.wrapper.hasAttribute("open"), s.config.folding.hint && e.wrapper.style.setProperty("will-change", "height"), s.config.fading.hint && e.element.style.setProperty("will-change", "opacity,visibility");
      } else {
        e.button = u2[t], e.element = u2[t + 1], e.wrapper = e.element;
        let c = [];
        s.config.folding.hint && c.push("max-height"), s.config.fading.hint && c.push("opacity", "visibility"), c.length > 0 && e.element.style.setProperty("will-change", c.join());
      }
      e.wrapper.setAttribute("role", "region");
      let g2 = e.button.classList.contains(d2.disabled), h2 = e.button.classList.contains(d2.opened), m = e.element.classList.contains(d2.expanded);
      e.button.ariaExpanded === "true" || h2 || m || f2 ? (h2 || e.button.classList.add(d2.opened), e.button.ariaExpanded !== "true" && (e.button.ariaExpanded = "true"), m || e.element.classList.add(d2.expanded), g2 && (e.button.classList.add(d2.disabled), e.button.ariaDisabled = "true", e.disabled = true), e.expanded = true) : e.button.ariaDisabled === "true" || g2 ? (e.disabled = true, g2 || e.button.classList.add(d2.disabled), e.button.ariaDisabled !== "true" && (e.button.ariaDisabled = "true"), m ? (e.expanded = true, e.button.ariaExpanded = "true") : (e.expanded = false, e.button.ariaExpanded = "false"), h2 && e.button.classList.remove(d2.opened)) : (e.expanded = false, e.disabled = false, e.button.ariaExpanded = "false", e.button.ariaDisabled = "false"), e.button.hasAttribute("id") || (e.button.id = `${s.id}B${e.index}`), e.element.hasAttribute("id") || (e.element.id = `${s.id}C${e.index}`), e.button.setAttribute("aria-controls", e.element.id), e.element.setAttribute("aria-labelledby", e.button.id), e.expanded ? (s.openCount = s.openCount + 1, s.semantic ? (e.height = e.button.offsetHeight + e.element.offsetHeight, e.wrapper.style.setProperty("height", `${e.height}px`)) : (e.height = e.element.scrollHeight, e.wrapper.style.setProperty("max-height", "0"))) : s.semantic ? (e.height = e.button.offsetHeight, e.wrapper.style.setProperty("height", `${e.height}px`)) : (e.height = 0, e.element.style.setProperty("max-height", "0")), s.folds.push(E2(s, p, e)), s.folds.refs[e.element.id] = s.folds.length - 1, t = t + a2;
    } while (t < o2);
    let r = (e, f2, g2 = false) => {
      if (typeof f2 == "number")
        return e.charCodeAt(0) === 100 ? s.folds[f2][e](g2) : s.folds[f2][e]();
      if (typeof f2 == "string") {
        for (let h2 of s.folds.values())
          if (h2.button.getAttribute(`${s.config.schema}-fold`) === f2)
            return e.charCodeAt(0) === 100 ? h2[e](g2) : h2[e]();
      }
      throw new Error(`Relapse: Fold does not exist: "${f2}"`);
    };
    s.on = p.on, s.off = p.off, s.collapse = (e) => r("close", e), s.expand = (e) => r("open", e), s.destroy = (e, f2 = false) => {
      if (typeof e == "undefined")
        for (let g2 of s.folds)
          g2.destroy();
      else
        r("destroy", e, f2);
      s.element.removeAttribute("aria-multiselectable"), p.emit("destroy", s), window.relapse.delete(i2);
    };
  }
  var x2 = function(l3, i2) {
    window.relapse instanceof Map || (window.relapse = /* @__PURE__ */ new Map());
    let s = typeof l3 == "object" && "tagName" in l3;
    if (s && l3 instanceof NodeList)
      throw TypeError("Relapse: Invalid NodeList selector, provide string or HTMLElement");
    let u2 = $2(s ? i2 : l3), o2 = null;
    if (s)
      o2 = typeof l3 == "string" ? document.body.querySelector(l3) : l3, o2 !== null && y2(o2, u2);
    else {
      let p = document.body.querySelectorAll(`[${u2.schema}]`);
      if (p.length > 0)
        for (let d2 of p)
          y2(d2, u2);
    }
    let a2 = Array.from(window.relapse.values());
    return window.relapse.size === 1 ? a2[0] : s ? a2[a2.length - 1] : a2;
  };
  x2.get = (n) => n ? window.relapse.get(n) : window.relapse;
  var A = x2;

  // node_modules/.pnpm/@hotwired+stimulus@3.2.2/node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left, right) => {
        const leftIndex = left.index, rightIndex = right.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application) {
      this.application = application;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[2];
    let keyFilter = matches[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName,
      eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
      identifier: matches[5],
      methodName: matches[6],
      keyFilter: matches[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map, key, value) {
    fetch(map, key).add(value);
  }
  function del(map, key, value) {
    fetch(map, key).delete(value);
    prune(map, key);
  }
  function fetch(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
        return match.concat(matches);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_2, index) => [left[index], right[index]]);
  }
  function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a2 = function() {
        this.a.call(this);
      };
      const b3 = extendWithReflect(a2);
      b3.prototype.a = function() {
      };
      return new b3();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application, definition) {
      this.application = application;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application) {
      this.application = application;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k, v2]) => Object.assign(Object.assign({}, memo), { [k]: v2 }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application = new this(element, schema);
      application.start();
      return application;
    }
    start() {
      return __async(this, null, function* () {
        yield domReady();
        this.logDebugActivity("application", "starting");
        this.dispatcher.start();
        this.router.start();
        this.logDebugActivity("application", "start");
      });
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read, writer: write } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // src/app/components/controller.ts
  var Controller2 = class extends Controller {
    /**
     * Stimulus Instance
     */
    static connect(controllers) {
      const stimulus = Application.start();
      for (const id in controllers) {
        stimulus.register(id.toLowerCase(), controllers[id]);
      }
    }
    /**
     * Document `<html>`
     *
     * Returns the html element from the `this.application`
     * selector exposed by stimulus.
     */
    get html() {
      return this.application.element;
    }
    /**
     * Document `<body>`
     *
     * Returns the body element from the `this.application`
     * selector exposed by stimulus.
     */
    get dom() {
      return this.application.element.lastElementChild;
    }
    /**
     * Get Controller
     *
     * Returns the controller instance and methods from Stimulus.
     * Optionally pass in an `id` parameter value, which would
     * be the DOM element `id=""` value.
     */
    controller(identifier, id) {
      return this.application.controllers.find(({ context }) => id ? context.identifier === identifier && context.element.id === id : context.identifier === identifier);
    }
  };

  // node_modules/.pnpm/qvp@0.3.2/node_modules/qvp/index.js
  var i = function(t) {
    if (Array.isArray(t))
      return t.forEach(i);
    if (!("id" in t)) {
      for (let s of ["onenter", "onexit", "oninit", "onresize"])
        if (s in t)
          throw new Error('qvp: Missing an "id" reference');
      return Object.entries(t).forEach(([s, o2]) => {
        let c = typeof t[s];
        if (c === "string")
          return i({ id: s, query: o2 });
        throw new TypeError(`qvp: Invalid query type. Expected "string" received "${c}"`);
      });
    }
    let n = g(t), { id: r } = n.screen;
    i.viewports.size || addEventListener("resize", u(() => {
      i.viewports.forEach((s) => {
        s.screen.active && s.onresize(window.innerWidth);
      });
    }, 25), true), i.viewports.has(r) ? console.warn(`qvp: The id "${r}" is already defined, use qvp.add() instead.`) : i.viewports.set(r, n);
  };
  i.viewports = /* @__PURE__ */ new Map();
  Object.defineProperty(i, "isTouch", { get() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  } });
  i.get = (e) => i.viewports.has(e) ? i.viewports.get(e) : false;
  i.add = (e, t) => {
    let n = i.get(e);
    if (n === false)
      return console.error(`qvp: There is no viewport using an id of "${e}"`);
    f(t, n.screen), n.screen.test.matches && n.onenter();
  };
  i.off = (e, t) => {
    let n = i.get(e.split(":")[0]);
    if (n === false || !(e in n.events))
      return;
    let r = n.events[e].length;
    if (typeof t == "number")
      t <= r - 1 && n.events[e].splice(t, 1);
    else if (typeof t == "function") {
      let s = [];
      for (let o2 = 0; o2 < r; o2++)
        n.events[e][o2] !== t && s.push(n.events[e][o2]);
      s.length > 0 && (n.events[e] = s);
    } else
      delete n.events[e];
  };
  i.on = (e, t, n) => {
    let [r, s] = e.split(":"), o2 = i.get(r);
    if (o2 === false)
      return;
    e in o2.events || (o2.events[e] = []);
    let c = n ? t.bind(n) : t;
    return c["qvp:event"] = o2.events[e].length, o2.events[e].push(c), o2.screen.test.matches ? s === "oninit" ? c.call() : (s === "onenter" && c.call(), f({ [s]: c }, o2.screen)) : f({ [s]: c }, o2.screen), c["qvp:event"];
  };
  i.list = (e) => {
    let t = Array.from(i.viewports.values()).map(({ screen: n }) => n);
    return e ? t.filter(({ id: n }) => e.includes(n)) : t;
  };
  i.active = (e) => {
    let t = i.list();
    if (e) {
      let r = i.get(e);
      return r ? r.screen.active : false;
    }
    let n = t.filter(({ active: r }) => r === true);
    return n.length > 1 ? n : n[0];
  };
  i.test = (e, t = ",") => typeof e == "string" ? e.indexOf(t) > -1 ? e.split(t).some(i.active) : !!i.active(e) : e.some(i.active);
  i.remove = (e) => {
    i.viewports.has(e) && (i.viewports.get(e).destroy(), i.viewports.delete(e));
  };
  i.destroy = () => {
    removeEventListener("resize", u()), i.viewports.forEach((e) => e.destroy()), i.viewports.clear();
  };
  i.screens = () => {
    throw Error("qvp: The qvp.screens() is deprecated, use the default import, e.g: qvp(...)");
  };
  function u(e, t) {
    let n = t;
    return function() {
      let r = () => {
        n = null, e.apply(this, arguments);
      };
      n && cancelAnimationFrame(n), n = requestAnimationFrame(r);
    };
  }
  function f(e, t) {
    typeof e.onenter == "function" && ("qvp:event" in e.onenter || (e.onenter["qvp:event"] = NaN), t.onenter.add(e.onenter)), typeof e.onexit == "function" && ("qvp:event" in e.onexit || (e.onexit["qvp:event"] = NaN), t.onexit.add(e.onexit)), typeof e.onresize == "function" && ("qvp:event" in e.onresize || (e.onresize["qvp:event"] = NaN), t.onresize.add(e.onresize)), typeof e.oninit == "function" && ("qvp:event" in e.oninit || (e.oninit["qvp:event"] = NaN), t.oninit.add(e.oninit));
  }
  function a(e, ...t) {
    let n = i.get(e.split(":")[0]);
    if (n !== false && e in n.events)
      for (let r = 0; r < n.events[e].length && (n.events[e][r].apply(null, t), e.endsWith(":oninit") && i.off(e, r), e in n.events); r++)
        ;
  }
  function g(e) {
    let t = e.query || "all", n = { id: e.id, query: t, active: false, test: matchMedia(t), onenter: /* @__PURE__ */ new Set(), onexit: /* @__PURE__ */ new Set(), onresize: /* @__PURE__ */ new Set(), oninit: /* @__PURE__ */ new Set(), events: /* @__PURE__ */ Object.create(null) };
    f(e, n);
    let r = () => {
      n.oninit.size > 0 && (n.oninit.forEach((v2) => !isNaN(v2["qvp:event"]) || v2()), a(`${e.id}:oninit`), n.oninit.clear()), n.onenter.forEach((v2) => !isNaN(v2["qvp:event"]) || v2()), a(`${e.id}:onenter`), n.active = true;
    }, s = () => {
      n.onexit.forEach((v2) => !isNaN(v2["qvp:event"]) || v2()), a(`${e.id}:onexit`), n.active = false;
    }, o2 = (v2) => {
      n.onresize.forEach((d2) => !isNaN(d2["qvp:event"]) || d2()), a(`${e.id}:onresize`, v2);
    }, c = ({ matches: v2 }) => v2 ? r() : s(), p = () => {
      for (let v2 in n.events)
        delete n.events[v2];
      n.test.removeEventListener("change", c);
    };
    return n.test.addEventListener("change", c), n.test.matches && r(), { onenter: r, onexit: s, onresize: o2, destroy: p, get screen() {
      return n;
    }, get events() {
      return n.events;
    } };
  }
  var l2 = i;

  // src/app/components/drawer.ts
  var _Drawer = class _Drawer extends Controller2 {
    constructor() {
      super(...arguments);
      this.transition = (event) => {
        if (event.propertyName !== "transform")
          return;
        if (this.hasShiftValue) {
          for (const shift of this.shifts) {
            if (shift.classList.contains(this.shiftClass)) {
              shift.classList.remove(this.shiftClass);
              shift.style.removeProperty("transform");
            }
          }
        }
        if (this.hasBackdropClass && this.backdrop.classList.contains(this.backdropClass)) {
          this.backdrop.classList.remove(this.backdropClass);
        }
        if (this.modeValue === "pull") {
          this.shifts.item(0).removeEventListener(event.type, this.transition);
        } else {
          this.target.removeEventListener(event.type, this.transition);
        }
      };
      /**
       * Click detected outside, eg: document body
       */
      this.outsideClick = (event) => {
        if (event.target !== this.target) {
          this.close();
          document.documentElement.removeEventListener("click", this.outsideClick, false);
        }
      };
      /**
       * Toggle Drawer
       */
      this.toggle = (event) => {
        if (event)
          event.preventDefault();
        this.isOpenValue = !this.isOpenValue;
        if (this.isOpenValue) {
          this.open();
        } else {
          this.close();
        }
        return this.isOpenValue ? this.open() : this.close();
      };
      /**
       * Touch Move prevention event
       */
      this.touchMove = (event) => {
        if (this.isOpenValue) {
          if (this.target.scrollHeight <= this.target.clientHeight) {
            event.preventDefault();
          }
        }
      };
      /**
       * Keyboard events
       */
      this.keyboard = (event) => {
        switch (event.code) {
          case "Esc":
          case "Escape":
            this.close();
            break;
        }
      };
    }
    /**
     * Returns the backdrop element
     */
    get backdrop() {
      return _Drawer.backdrop;
    }
    /**
     * Returns the drawer direction class name
     */
    get directionClass() {
      return `drawer-${this.directionValue}`;
    }
    /**
     * Returns the drawer shift class name
     */
    get shiftClass() {
      return `drawer-${this.modeValue}`;
    }
    /**
     * Returns the shifts transition class name
     */
    get shifts() {
      return document.documentElement.querySelectorAll(this.shiftValue);
    }
    /**
     * Returns all button toggles in the dom
     */
    get buttons() {
      return document.documentElement.querySelectorAll(`[data-drawer="${this.target.id}"]`);
    }
    /**
     * Stimulus: Initialize
     */
    initialize() {
      if (!_Drawer.backdrop) {
        _Drawer.backdrop = document.createElement("div");
        _Drawer.backdrop.className = "drawer-backdrop";
        _Drawer.backdrop.setAttribute("spx-morph", "false");
      }
      if (this.useParentValue) {
        this.target = this.element.parentElement;
        this.target.ariaHidden = "true";
      } else {
        this.target = this.element;
      }
      if (this.target.classList.contains("d-none")) {
        this.target.classList.remove("d-none");
      }
      if (this.modeValue !== "overlay" && this.hasShiftValue === false) {
        console.error('Missing "data-drawer-shift-value" defintions on:', this.target);
      }
      Ps.on("load", this.onLoad, this);
    }
    /**
     * Stimulus: Connect
     */
    connect() {
      for (const button of this.buttons) {
        button.addEventListener("click", this.toggle);
      }
      if (document.documentElement.contains(_Drawer.backdrop) === false) {
        document.documentElement.appendChild(_Drawer.backdrop);
      }
      if (this.hasWidthValue) {
        this.target.style.setProperty("width", this.widthValue);
      }
      if (this.hasHeightValue) {
        this.target.style.setProperty("height", this.heightValue);
      }
      if (this.hasDirectionValue && this.target.classList.contains(this.directionClass) === false) {
        this.target.classList.add(this.directionClass);
      }
      if (this.modeValue === "pull") {
        this.target.style.setProperty("transform", "translateX(0)");
        this.target.style.setProperty("z-index", "0");
      }
      if (this.html.classList.contains("drawer-open")) {
        this.html.classList.remove("drawer-open");
      }
    }
    /**
     * Stimulus: Disconnect
     */
    disconnect() {
    }
    onLoad() {
      if (this.isOpenValue) {
        if (l2.test(["lg", "xl", "xxl"])) {
          this.close();
        } else {
          setTimeout(this.close.bind(this), 250);
        }
      }
    }
    /**
     * Open Drawer
     */
    open() {
      if (!this.target.classList.contains("drawer-active")) {
        this.target.classList.add("drawer-active");
      }
      if (this.hasBackdropClass && !this.backdrop.classList.contains(this.backdropClass)) {
        this.backdrop.classList.add(this.backdropClass);
      }
      if (this.bodyScrollValue === false) {
        document.documentElement.style.setProperty("overflow", "hidden");
      }
      if (this.hasShiftValue) {
        this.shiftNodes();
      }
      if (this.hasWidthValue) {
        if (this.directionValue === "top") {
          this.backdrop.style.setProperty("transform", `translateY(-${this.offsetValue})`);
        } else {
          this.backdrop.style.setProperty("transform", `translateX(${this.widthValue})`);
        }
      }
      this.html.classList.add("drawer-open");
      this.backdrop.addEventListener("click", this.toggle, { once: true });
      this.target.addEventListener("touchstart", this.touchStart, { passive: true });
      this.target.ariaHidden = "false";
    }
    close() {
      if (this.isOpenValue) {
        this.isOpenValue = false;
      }
      if (this.hasWidthValue) {
        this.backdrop.style.removeProperty("transform");
      }
      if (this.bodyScrollValue === false) {
        document.documentElement.style.removeProperty("overflow");
      }
      if (this.hasShiftValue) {
        this.shiftNodes();
      } else {
        this.target.addEventListener("transitionend", this.transition);
      }
      this.html.classList.remove("drawer-open");
      this.target.removeEventListener("touchstart", this.touchStart);
      this.backdrop.removeEventListener("click", this.toggle);
      this.target.classList.remove("drawer-active");
      this.target.ariaHidden = "true";
    }
    /**
     * Set attribute requirements for the elements which apply transform shifting
     */
    shiftNodes() {
      if (this.modeValue === "pull") {
        this.target.style.setProperty("transform", "translateX(0)");
        this.target.style.setProperty("z-index", "0");
        if (this.isOpenValue === false) {
          this.shifts.item(0).addEventListener("transitionend", this.transition);
        }
      } else {
        if (this.isOpenValue === false) {
          this.target.addEventListener("transitionend", this.transition);
        }
      }
      for (const shift of this.shifts) {
        if (this.isOpenValue) {
          if (!shift.classList.contains(this.shiftClass)) {
            shift.classList.add(this.shiftClass);
          }
          if (this.hasWidthValue && (this.directionValue === "left" || this.directionValue === "right")) {
            shift.style.setProperty("transform", `translateX(${this.widthValue})`);
          } else if (this.hasHeightValue && (this.directionValue === "top" || this.directionValue === "bottom")) {
            shift.style.setProperty("transform", `translateY(${this.heightValue})`);
          }
        } else {
          if (this.hasWidthValue && (this.directionValue === "left" || this.directionValue === "right")) {
            shift.style.setProperty("transform", "translateX(0)");
          } else if (this.hasHeightValue && (this.directionValue === "top" || this.directionValue === "bottom")) {
            shift.style.setProperty("transform", "translateY(0)");
          }
        }
      }
    }
    /**
     * Touch Start scroll position
     */
    touchStart({ target }) {
      if (target instanceof HTMLElement) {
        const { scrollTop, offsetHeight } = target;
        const position = scrollTop + offsetHeight;
        if (scrollTop === 0) {
          target.scrollTop = 1;
        } else if (position === scrollTop) {
          target.scrollTop = scrollTop - 1;
        }
      }
    }
  };
  /**
   * Stimulus: values
   */
  _Drawer.values = {
    outsideClick: Boolean,
    height: String,
    width: String,
    offset: String,
    direction: String,
    shift: String,
    redraw: String,
    useParent: {
      type: Boolean,
      default: false
    },
    isOpen: {
      type: Boolean,
      default: false
    },
    bodyScroll: {
      type: Boolean,
      default: false
    },
    backdrop: {
      type: Boolean,
      default: true
    },
    mode: {
      type: String,
      default: "overlay"
    }
  };
  /**
   * Stimulus: values
   */
  _Drawer.targets = [
    "mount"
  ];
  /**
   * Stimulus: values
   */
  _Drawer.classes = [
    "backdrop"
  ];
  var Drawer = _Drawer;

  // src/app/components/tabs.ts
  var Tabs = class extends Controller {
    toggle({ target }) {
      this.openValue = +target.getAttribute("data-index");
      for (const btn of this.btnTargets) {
        btn.classList.remove("active");
      }
      for (const tab of this.tabTargets) {
        tab.classList.remove("d-block");
        tab.classList.add("d-none");
      }
      this.btnTargets[this.openValue].classList.add("active");
      this.tabTargets[this.openValue].classList.remove("d-none");
      this.tabTargets[this.openValue].classList.add("d-block");
    }
  };
  Tabs.targets = [
    "tab",
    "btn"
  ];
  Tabs.values = {
    open: {
      default: 0,
      type: Number
    }
  };

  // src/app/bundle.ts
  Ps.connect(
    {
      targets: ["#main", ".spx"],
      render: "morph"
    }
  )(function() {
    Controller2.connect(
      {
        Tabs,
        Drawer
      }
    );
    A();
  });
  Ps.on("visit", () => {
    window.relapse.forEach((scope, key) => {
      if (!key.startsWith("sidebar"))
        scope.destroy();
    });
  });
  Ps.on("load", () => {
    A();
  });

})();
