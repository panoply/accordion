// ../index.js
var I = (i) => ({ emit: (c2, e, d) => {
  let t = i[c2] || [], f = t.length, p = null;
  for (let u = 0; u < f; u++) {
    let a = t[u].apply(e, [d]);
    p === null && a === false && (p = true);
  }
  return p;
}, on: (c2, e) => {
  i[c2] || (i[c2] = []), i[c2].push(e);
}, off: (c2, e) => {
  let d = [], t = i[c2];
  if (t && e) {
    let f = 0, p = t.length;
    for (; f < p; f++)
      t[f] !== e && d.push(t[f]);
  }
  d.length ? t[c2] = d : delete t[c2];
} });
function E(i, c2) {
  let { config: e } = i, { classes: d } = e;
  return (t) => {
    let f = (a) => {
      i.collapsing = true;
      let { fade: n, transition: m } = a, { scrollHeight: h, style: b } = a.content, A = performance.now(), g = requestAnimationFrame(function l(s) {
        let r = Math.min((s - A) / m, 1);
        r < 1 ? (n && r > 0 && (b.opacity = `${1 - r}`), b.height = `${h - r * h}px`, g = requestAnimationFrame(l)) : r >= 1 && (b.height = "0", n && (b.opacity = "0"), a.button.ariaDisabled = "false", a.button.ariaExpanded = "false", a.button.classList.remove(d.opened), a.content.classList.remove(d.expanded), a.expanded = false, i.collapsing = false, cancelAnimationFrame(g));
      });
    }, p = (a) => {
      i.collapsing = true;
      let { fade: n, transition: m } = a, { scrollHeight: h, style: b } = a.content, A = performance.now();
      n || (b.opacity = "1");
      let g = requestAnimationFrame(function l(s) {
        let r = Math.min((s - A) / m, 1);
        r < 1 ? (n && r > 0 && (b.opacity = `${r}`), b.height = `${r * h}px`, g = requestAnimationFrame(l)) : r >= 1 && (n && (b.opacity = "1"), b.height = "auto", i.collapsing = false, cancelAnimationFrame(g));
      });
    }, u = (a) => {
      if (typeof a != "number")
        return i.active !== t.number && (i.active = t.number), t;
      if (i.folds[a])
        return i.active = t.number, i.folds[a];
      throw new TypeError(`No fold exists at index: ${a}`);
    };
    t.focus = () => {
      i.active = t.number, t.button.classList.add(d.focused), c2.emit("focus", i, t);
    }, t.blur = () => t.button.classList.remove(d.focused), t.enable = (a) => {
      let n = u(a);
      n.disabled && (n.disabled = false, n.button.ariaDisabled = "false", n.button.classList.remove(d.disabled));
    }, t.disable = (a) => {
      let n = u(a);
      n.disabled || (n.expanded ? e.persist && (n.disabled = true, n.button.ariaDisabled = "true") : (n.close(), n.disabled = true, n.button.ariaDisabled = "true", n.button.classList.add(d.disabled)));
    }, t.close = (a) => {
      let n = u(a);
      if (e.multiple && !n.expanded)
        f(n);
      else
        for (let m of i.folds)
          if (m.expanded) {
            if (e.persist && m.number === n.number)
              break;
            f(m), n = m;
            break;
          }
      n.enable(), c2.emit("collapse", i, n);
    }, t.open = (a) => {
      let n = u(a);
      n.expanded || n.disabled || (n.close(), p(n), n.expanded = true, n.button.ariaDisabled = "true", n.button.ariaExpanded = "true", n.button.classList.add(d.opened), n.content.classList.add(d.expanded), n.disable(), c2.emit("expand", i, n));
    }, t.toggle = () => {
      if (!i.collapsing && !c2.emit("toggle", i, t))
        return t.expanded ? t.close() : t.open();
    }, t.destroy = (a = false) => {
      t.close(), t.button.removeEventListener("click", t.toggle), t.button.removeEventListener("focus", t.focus), t.button.removeEventListener("blur", t.blur), a && (i.element.removeChild(t.content), i.element.removeChild(t.button));
    }, t.button.addEventListener("click", t.toggle), t.button.addEventListener("focus", t.focus), t.button.addEventListener("blur", t.blur), i.folds.push(t);
  };
}
var v = (i) => {
  let c2 = i.trim();
  if (!/true|false/.test(c2))
    throw new TypeError(`Invalid value. Boolean expected, received: ${c2}`);
  return c2 === "true";
};
var x = (i) => {
  let c2 = i.trim();
  if (/[-]?[0-9]/.test(c2)) {
    if (c2.charCodeAt(0) === 45)
      throw new TypeError(`Negative transition is not allowed: ${c2}`);
    return Number(c2);
  }
  return v(c2) ? 300 : 0;
};
var O = (i, c2) => {
  let e = /* @__PURE__ */ Object.create(null), d = /* @__PURE__ */ Object.create(null);
  d.opened = "opened", d.disabled = "disable", d.expanded = "expanded", d.focused = "focused", "classes" in i && Object.assign(d, i.classes), e.classes = d, e.persist = true, e.multiple = false, e.fade = true, e.schema = "data-accordion", typeof i == "object" && Object.assign(e, i);
  let t = /^(?:preserve|persist|multiple|keyboard|transition|fade)$/, f = e.schema === null ? 5 : e.schema.length + 1;
  for (let { nodeName: p, nodeValue: u } of c2) {
    let a = p.slice(f);
    t.test(a) && (e[a] = a === "transition" ? x(u) : v(u));
  }
  return "transition" in e || (e.transition = 300), e;
};
function $(i, c2) {
  window.relapse instanceof Map || (window.relapse = /* @__PURE__ */ new Map());
  let e = /* @__PURE__ */ Object.create(null);
  if (e.folds = [], e.events = /* @__PURE__ */ Object.create(null), e.element = typeof i == "string" ? document.body.querySelector(i) : i, e.id = e.element.id ? e.element.id : `A${window.relapse.size}`, window.relapse.has(e.id))
    throw new TypeError(`An accordion using id ${e.id} alrerady exists`);
  e.config = O(c2, e.element.attributes), e.element.ariaMultiSelectable = `${e.config.multiple}`, e.collapsing = false;
  let d = e.element.children, t = d.length, f = I(e.events), p = E(e, f), { classes: u, schema: a, transition: n, fade: m } = e.config, h = a === null ? "data" : a, b = `${h}-fade`, A = `${h}-transition`;
  for (let l = 0; l < t; l = l + 2) {
    let s = d[l], r = d[l + 1], o = /* @__PURE__ */ Object.create(null);
    o.number = e.folds.length;
    let w = s.classList.contains(u.opened), y = s.classList.contains(u.disabled), L = r.classList.contains(u.expanded);
    s.ariaExpanded === "true" || w || L ? (w ? s.ariaExpanded = "true" : s.classList.add(u.opened), L || r.classList.add(u.expanded), y || s.classList.add(u.disabled), s.ariaDisabled = "true", o.expanded = true, o.disabled = true) : s.ariaDisabled === "true" || y ? (y ? s.ariaDisabled = "false" : s.classList.add(u.disabled), r.classList.remove(u.expanded), s.classList.remove(u.opened), s.ariaExpanded = "false", o.expanded = false, o.disabled = true) : (o.expanded = false, o.disabled = false, s.ariaExpanded = "false", s.ariaDisabled = "false"), o.transition = n, o.fade = m, s.id && (o.id = s.id), r.id && (o.id = r.id), "id" in o || (o.id = `${e.id}F${o.number}`, s.id = `B${o.id}`, r.id = `C${o.id}`), s.hasAttribute(A) && (o.transition = x(s.getAttribute(A))), r.hasAttribute(A) && (o.transition = x(r.getAttribute(A))), s.hasAttribute(b) && (o.fade = v(s.getAttribute(b))), r.hasAttribute(b) && (o.fade = v(r.getAttribute(b))), o.fade || (r.style.opacity = "1"), s.setAttribute("aria-controls", o.id), r.setAttribute("aria-labelledby", s.id), r.setAttribute("role", "region"), o.button = s, o.content = r, p(o);
  }
  let g = (l, s, r = false) => {
    if (typeof s == "number")
      return l.charCodeAt(0) === 100 ? e.folds[s][l](r) : e.folds[s][l]();
    if (typeof s == "string") {
      for (let o of e.folds)
        if (o.button.dataset[`${e.config.schema}-fold`] === s)
          return l.charCodeAt(0) === 100 ? o[l](r) : o[l]();
    }
    throw new TypeError(`Fold does not exist: "${s}"`);
  };
  return e.on = f.on, e.off = f.off, e.collapse = (l) => g("close", l), e.expand = (l) => g("open", l), e.destroy = (l, s = false) => {
    if (typeof l == "undefined")
      for (let r of e.folds)
        r.destroy();
    else
      g("destroy", l, s);
    e.element.removeAttribute("aria-multiselectable"), f.emit("destroy", e), window.relapse.delete(e.id);
  }, window.relapse.set(e.id, e), e;
}

// site/assets/bundle.ts
var c = $(document.querySelector("#accordion"), {
  transition: 300,
  multiple: false
});
c.on("toggle", function(fold) {
});
